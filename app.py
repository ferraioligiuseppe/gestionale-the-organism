import streamlit as st
import sqlite3
import psycopg2
import psycopg2.extras
import re
from datetime import date, datetime
from typing import Optional, Dict
import os
import io
import csv
from functools import lru_cache
import math  # <-- aggiungi questa riga se non c'Ã¨
import textwrap  # per andare a capo nel referto



# -----------------------------
# DB migrations helpers
# -----------------------------
def _table_has_column(cur: sqlite3.Cursor, table: str, column: str) -> bool:
    cur.execute(f"PRAGMA table_info({table})")
    cols = [r[1] for r in cur.fetchall()]
    return column in cols

def ensure_column(cur: sqlite3.Cursor, table: str, column: str, col_type_sql: str, default_sql: str | None = None):
    """Aggiunge una colonna se manca (migrazione non distruttiva)."""
    if _table_has_column(cur, table, column):
        return
    ddl = f"ALTER TABLE {table} ADD COLUMN {column} {col_type_sql}"
    if default_sql is not None:
        ddl += f" DEFAULT {default_sql}"
    cur.execute(ddl)

def now_iso_seconds() -> str:
    return datetime.now().replace(microsecond=0).isoformat()

# Export Excel
try:
    from openpyxl import Workbook
    from openpyxl.styles import Font
    OPENPYXL_AVAILABLE = True
except ImportError:
    OPENPYXL_AVAILABLE = False

# PDF (referti e prescrizioni A4/A5)
try:
    from reportlab.lib.pagesizes import A4, A5
    from reportlab.pdfgen import canvas
    from reportlab.lib.units import mm
    REPORTLAB_AVAILABLE = True
except ImportError:
    REPORTLAB_AVAILABLE = False

# -----------------------------
# Carta intestata (template grafico)
# -----------------------------
import base64
from reportlab.lib.utils import ImageReader

# Immagine A4 con intestazione + footer (solo grafica, area centrale vuota)
LETTERHEAD_A4_JPG_B64 = (
    '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'
    '3R+G1+4+Xjsv7vN0fhtfuWU+LNN+z8b8mn9D4s037Pxvyaf0NhjPGj0xzOo5v5uPbjmrX8vHZf3ebo/Da/cfLx2X93m6Pw2v3LKfFmm/Z+N+TT+h8Wab9n435NP6GwxnjR6Y5nUc383HtxzVr+Xjsv7vN0fhtfuPl47L+7zdH4bX7llPizTfs/G/Jp/Q+LNN+z8b8mn9DYYzxo9MczqOb+bj245q1/Lx2X93m6Pw2v3Hy8dl/d5uj8Nr9yynxZpv2fjfk0/ofFmm/Z+N+TT+hsMZ40emOZ1HN/Nx7cc1a/l47L+7zdH4bX7hZT4s037Pxvyaf0DYYzxo9MczqOb+bj245u0AsF+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
    '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'
)

def _get_letterhead_a4_reader() -> ImageReader:
    """Restituisce ImageReader della carta intestata A4 (grafica)."""
    data = base64.b64decode(''.join(LETTERHEAD_A4_JPG_B64))
    return ImageReader(io.BytesIO(data))

def _draw_image_cover(c, img_reader: ImageReader, pagesize):
    """Disegna un'immagine a piena pagina tipo 'cover' (senza distorsioni), centrando e ritagliando se necessario."""
    w, h = pagesize
    iw, ih = img_reader.getSize()
    if iw <= 0 or ih <= 0:
        return
    scale = max(w / iw, h / ih)
    dw, dh = iw * scale, ih * scale
    x = (w - dw) / 2.0
    y = (h - dh) / 2.0
    c.drawImage(img_reader, x, y, width=dw, height=dh, preserveAspectRatio=True, mask='auto')

def _draw_image_contain(c, img_reader: ImageReader, pagesize):
    """Disegna un'immagine a piena pagina tipo 'contain' (senza distorsioni), centrando senza ritagliare.

    Usare questa modalitÃ  per la carta intestata, cosÃ¬ TUTTA la grafica (nome medico e indirizzi) resta visibile.
    """
    w, h = pagesize
    iw, ih = img_reader.getSize()
    if iw <= 0 or ih <= 0:
        return
    scale = min(w / iw, h / ih)
    dw, dh = iw * scale, ih * scale
    x = (w - dw) / 2.0
    y = (h - dh) / 2.0
    c.drawImage(img_reader, x, y, width=dw, height=dh, preserveAspectRatio=True, mask='auto')



def draw_letterhead_background(c, pagesize=A4, variant: str = "CIRILLO"):
    """Disegna la carta intestata (grafica) come sfondo dell'intera pagina.

    variant:
      - "CIRILLO": grafica completa (con intestazione del Dott. Cirillo)
      - "ORG_ONLY": stessa grafica, ma senza il blocco nome/titoli del medico (coperto in bianco)
    """
    w, h = pagesize
    try:
        img = _get_letterhead_a4_reader()
        _draw_image_contain(c, img, pagesize)

        if variant == "ORG_ONLY":
            # Copre l'area in alto a sinistra dove compare il nome/titoli del medico
            # (valori conservativi per funzionare sia A4 che A5: adattati alla pagina).
            c.saveState()
            c.setFillColorRGB(1, 1, 1)
            # Copertura ~10.5 cm larghezza x ~3.0 cm altezza
            from reportlab.lib.units import cm
            c.rect(0, h - (0.11*h), 0.5*w, (0.11*h), stroke=0, fill=1)
            c.restoreState()
    except Exception:
        # se qualcosa va storto (es. librerie mancanti), non blocchiamo la generazione
        pass


# -----------------------------
# Configurazione accesso (login semplice)
# -----------------------------

# -----------------------------
# Auth (Secrets in cloud, fallback locale)
# -----------------------------
def _load_users():
    # 1) Multi-utente: [users]
    try:
        users = dict(st.secrets["users"])
        if users:
            return {str(k): str(v) for k, v in users.items()}
    except Exception:
        pass

    # 2) Singolo utente: [auth]
    try:
        u = st.secrets["auth"]["username"]
        p = st.secrets["auth"]["password"]
        if u and p:
            return {str(u): str(p)}
    except Exception:
        pass

    # In cloud: NO fallback
    if _running_on_cloud():
        st.error("ð Secrets mancanti: configura [auth] o [users] in Streamlit Cloud â Settings â Secrets.")
        st.stop()

    # Fallback SOLO locale
    return {"admin": "admin123"}

def login() -> bool:
    """
    Login semplice con username/password.
    In Streamlit Cloud usa SOLO i Secrets (nessun fallback).
    """
    users = _load_users()

    if "logged_in" not in st.session_state:
        st.session_state.logged_in = False
    if "logged_user" not in st.session_state:
        st.session_state.logged_user = None

    if st.session_state.logged_in:
        return True

    st.title("The Organism â Login")
    user = st.text_input("Username")
    pwd = st.text_input("Password", type="password")

    if st.button("Entra"):
        if user in users and users[user] == pwd:
            st.session_state.logged_in = True
            st.session_state.logged_user = user
            st.rerun()
        else:
            st.error("Credenziali non valide")

    return False
def _running_on_cloud() -> bool:
    # Streamlit Community Cloud monta il repo in /mount/src/...
    try:
        return "/mount/src/" in os.getcwd()
    except Exception:
        return False

def _get_database_url() -> str:
    # 1) Streamlit Secrets: [db].DATABASE_URL
    try:
        v = st.secrets["db"]["DATABASE_URL"]
        if v:
            return str(v)
    except Exception:
        pass

    # 2) Streamlit Secrets root: DATABASE_URL (se presente)
    try:
        v = st.secrets["DATABASE_URL"]
        if v:
            return str(v)
    except Exception:
        pass

    # 3) env var
    return os.getenv("DATABASE_URL", "") or ""
_DB_URL = _get_database_url()
_DB_BACKEND = "postgres" if _DB_URL else "sqlite"

# In cloud: NON permettere SQLite (evita ricreazione .db e ambiguitÃ )
if _running_on_cloud() and _DB_BACKEND != "postgres":
    st.error("â DATABASE_URL mancante nei Secrets: in Streamlit Cloud il gestionale richiede PostgreSQL (Neon).")
    st.stop()

# Wrapper minimale per usare psycopg2 con SQL scritto in stile SQLite ("?" placeholders)
# NB: init_db() crea/migra tabelle SOLO in SQLite. In Postgres si assume DB giÃ  migrato.
class _PgCursor:
    def __init__(self, cur):
        self._cur = cur
        self.lastrowid = None  # compatibilitÃ 

    def execute(self, query, params=None):
        if params is None:
            params = ()
        q = str(query)
        # Converti placeholders SQLite (?) -> psycopg2 (%s)
        if "?" in q:
            q = q.replace("?", "%s")

        # Auto-RETURNING per INSERT che usano ID autoincrement (per compatibilitÃ  con lastrowid)
        q_strip = q.lstrip().upper()
        if q_strip.startswith("INSERT INTO") and "RETURNING" not in q_strip:
            # se inserisci in Pazienti e vuoi l'ID
            # proviamo a capire se la tabella ha colonna "ID" e aggiungiamo RETURNING id
            try:
                tbl = q_strip.split()[2].strip('"')
            except Exception:
                tbl = ""
            if tbl in ("PAZIENTI",):
                q = q.rstrip().rstrip(";") + ' RETURNING id'
                self._cur.execute(q, params)
                try:
                    row = self._cur.fetchone()
                    if row is not None:
                        # RealDictCursor ritorna dict; cursor standard tuple
                        self.lastrowid = row.get("id") if isinstance(row, dict) else row[0]
                except Exception:
                    pass
                return self
        self._cur.execute(q, params)
        return self

    def executemany(self, query, seq_of_params):
        q = str(query)
        if "?" in q:
            q = q.replace("?", "%s")
        self._cur.executemany(q, seq_of_params)
        return self

    def fetchone(self):
        return self._cur.fetchone()

    def fetchall(self):
        return self._cur.fetchall()

    def __iter__(self):
        return iter(self._cur)

    def close(self):
        return self._cur.close()

class _PgConn:
    def __init__(self, conn):
        self._conn = conn

    def cursor(self):
        return _PgCursor(self._conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor))

    def commit(self):
        return self._conn.commit()

    def rollback(self):
        return self._conn.rollback()

    def close(self):
        return self._conn.close()


def _sidebar_db_indicator():
    """Mostra quale DB sta usando davvero (SQLite vs PostgreSQL)."""
    try:
        if _DB_BACKEND == "postgres":
            # prova reale
            try:
                import psycopg2
                c = psycopg2.connect(_DB_URL)
                cur = c.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
                cur.execute("SELECT current_database()")
                dbname = cur.fetchone()[0]
                c.close()
            except Exception:
                dbname = "postgres"
            st.sidebar.success(f"ð¢ DB: PostgreSQL ({dbname})")
        else:
            st.sidebar.warning(f"ð¡ DB: SQLite ({DB_PATH})")
    except Exception:
        pass


def get_connection():
    # Postgres (cloud)
    if _DB_BACKEND == "postgres":
        conn = psycopg2.connect(_DB_URL)
        return _PgConn(conn)

    # SQLite (locale)
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def init_db() -> None:
    # In Postgres (Neon) si assume DB giÃ  migrato: non creare/migrare qui (SQL Ã¨ SQLite-specifico).
    if _DB_BACKEND == "postgres":
        return

    conn = get_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)


    # Pazienti
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS Pazienti (
            ID              INTEGER PRIMARY KEY AUTOINCREMENT,
            Cognome         TEXT NOT NULL,
            Nome            TEXT NOT NULL,
            Data_Nascita    TEXT,
            Sesso           TEXT,
            Telefono        TEXT,
            Email           TEXT,
            Indirizzo       TEXT,
            CAP             TEXT,
            Citta           TEXT,
            Provincia       TEXT,
            Codice_Fiscale  TEXT,
            Stato_Paziente  TEXT NOT NULL DEFAULT 'ATTIVO'
        );
        """
    )

    # Anamnesi (schema semplice, ma useremo uno schema "ricco" nel campo Storia)
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS Anamnesi (
            ID              INTEGER PRIMARY KEY AUTOINCREMENT,
            Paziente_ID     INTEGER NOT NULL,
            Data_Anamnesi   TEXT,
            Motivo          TEXT,
            Storia          TEXT,
            Note            TEXT,
            FOREIGN KEY (Paziente_ID) REFERENCES Pazienti(ID)
        );
        """
    )

    # Valutazioni visive / oculistiche
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS Valutazioni_Visive (
            ID                      INTEGER PRIMARY KEY AUTOINCREMENT,
            Paziente_ID             INTEGER NOT NULL,
            Data_Valutazione        TEXT,
            Tipo_Visita             TEXT,
            Professionista          TEXT,
            Acuita_Nat_OD           TEXT,
            Acuita_Nat_OS           TEXT,
            Acuita_Nat_OO           TEXT,
            Acuita_Corr_OD          TEXT,
            Acuita_Corr_OS          TEXT,
            Acuita_Corr_OO          TEXT,
            Costo                   REAL,
            Pagato                  INTEGER NOT NULL DEFAULT 0,
            Anamnesi                TEXT,
            Esame                   TEXT,
            Conclusioni             TEXT,
            Note                    TEXT,
            FOREIGN KEY (Paziente_ID) REFERENCES Pazienti(ID)
        );
        """
    )


    # Migrazioni (workflow valutazioni): aggiunge colonne se il DB era giÃ  esistente
    ensure_column(cur, "Valutazioni_Visive", "Stato_Valutazione", "TEXT", "'BOZZA'")
    ensure_column(cur, "Valutazioni_Visive", "Creato_Il", "TEXT")
    ensure_column(cur, "Valutazioni_Visive", "Aggiornato_Il", "TEXT")

    # Migrazione soft: aggiunge colonne nuove senza rompere DB esistenti
    cur.execute("PRAGMA table_info(Valutazioni_Visive)")
    cols = {r[1] for r in cur.fetchall()}
    if "Anamnesi" not in cols:
        cur.execute("ALTER TABLE Valutazioni_Visive ADD COLUMN Anamnesi TEXT")

    if "Esame" not in cols:
        cur.execute("ALTER TABLE Valutazioni_Visive ADD COLUMN Esame TEXT")
    if "Conclusioni" not in cols:
        cur.execute("ALTER TABLE Valutazioni_Visive ADD COLUMN Conclusioni TEXT")

    # Sedute / Terapie
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS Sedute (
            ID              INTEGER PRIMARY KEY AUTOINCREMENT,
            Paziente_ID     INTEGER NOT NULL,
            Data_Seduta     TEXT,
            Terapia         TEXT,
            Professionista  TEXT,
            Costo           REAL,
            Pagato          INTEGER NOT NULL DEFAULT 0,
            Note            TEXT,
            FOREIGN KEY (Paziente_ID) REFERENCES Pazienti(ID)
        );
        """
    )
    # Coupons (OF / SDS)
    cur.execute(
        """
        CREATE TABLE IF NOT EXISTS Coupons (
            ID                INTEGER PRIMARY KEY AUTOINCREMENT,
            Paziente_ID       INTEGER NOT NULL,
            Tipo_Coupon       TEXT NOT NULL,     -- OF o SDS
            Codice_Coupon     TEXT,              -- numero / codice coupon
            Data_Assegnazione TEXT,
            Note              TEXT,
            Utilizzato        INTEGER NOT NULL DEFAULT 0,
            FOREIGN KEY (Paziente_ID) REFERENCES Pazienti(ID)
        );
        """
    )


    conn.commit()
    conn.close()


# -----------------------------
# Export: Pazienti (Excel)
# -----------------------------
def export_pazienti_excel(*, include_archiviati: bool = False) -> bytes:
    """Esporta la tabella Pazienti in un file Excel (.xlsx) e ritorna i bytes.
    Se include_archiviati=False esporta solo Stato_Paziente = ATTIVO.
    """
    if not OPENPYXL_AVAILABLE:
        raise RuntimeError("openpyxl non disponibile")

    conn = get_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
    cur.execute("SELECT * FROM Pazienti " + ("" if include_archiviati else "WHERE Stato_Paziente = 'ATTIVO' ") + "ORDER BY Cognome, Nome")
    rows = cur.fetchall()
    conn.close()

    wb = Workbook()
    ws = wb.active
    ws.title = "Pazienti"

    headers = list(rows[0].keys()) if rows else [
        "ID","Cognome","Nome","Data_Nascita","Sesso","Telefono","Email","Indirizzo","CAP","Citta","Provincia","Codice_Fiscale","Stato_Paziente"
    ]
    ws.append(headers)
    bold = Font(bold=True)
    for cell in ws[1]:
        cell.font = bold
    ws.freeze_panes = "A2"

    for r in rows:
        ws.append([r[h] if h in r.keys() else None for h in headers])

    # larghezze base (senza impazzire)
    for col_idx, h in enumerate(headers, start=1):
        ws.column_dimensions[chr(64+col_idx)].width = max(12, min(35, len(h)+2))

    bio = io.BytesIO()
    wb.save(bio)
    return bio.getvalue()


# -----------------------------
# Helpers: Codice Fiscale
# -----------------------------

MESE_CF = {
    1: "A",
    2: "B",
    3: "C",
    4: "D",
    5: "E",
    6: "H",
    7: "L",
    8: "M",
    9: "P",
    10: "R",
    11: "S",
    12: "T",
}

# -----------------------------
# Tabelle e funzioni per Codice Fiscale
# -----------------------------

CONTROL_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

ODD_MAP = {
    "0": 1,  "1": 0,  "2": 5,  "3": 7,  "4": 9,
    "5": 13, "6": 15, "7": 17, "8": 19, "9": 21,
    "A": 1,  "B": 0,  "C": 5,  "D": 7,  "E": 9,
    "F": 13, "G": 15, "H": 17, "I": 19, "J": 21,
    "K": 2,  "L": 4,  "M": 18, "N": 20, "O": 11,
    "P": 3,  "Q": 6,  "R": 8,  "S": 12, "T": 14,
    "U": 16, "V": 10, "W": 22, "X": 25, "Y": 24,
    "Z": 23,
}

EVEN_MAP = {
    "0": 0,  "1": 1,  "2": 2,  "3": 3,  "4": 4,
    "5": 5,  "6": 6,  "7": 7,  "8": 8,  "9": 9,
    "A": 0,  "B": 1,  "C": 2,  "D": 3,  "E": 4,
    "F": 5,  "G": 6,  "H": 7,  "I": 8,  "J": 9,
    "K": 10, "L": 11, "M": 12, "N": 13, "O": 14,
    "P": 15, "Q": 16, "R": 17, "S": 18, "T": 19,
    "U": 20, "V": 21, "W": 22, "X": 23, "Y": 24,
    "Z": 25,
}

def _solo_lettere(s: str) -> str:
    return "".join(ch for ch in s.upper() if ch.isalpha())

def _codice_cognome(cognome: str) -> str:
    s = _solo_lettere(cognome)
    consonanti = [c for c in s if c not in "AEIOU"]
    vocali = [c for c in s if c in "AEIOU"]
    codice = "".join(consonanti + vocali)[:3]
    return (codice + "XXX")[:3]

def _codice_nome(nome: str) -> str:
    s = _solo_lettere(nome)
    consonanti = [c for c in s if c not in "AEIOU"]
    vocali = [c for c in s if c in "AEIOU"]
    if len(consonanti) >= 4:
        # regola CF: 1a, 3a e 4a consonante
        codice = consonanti[0] + consonanti[2] + consonanti[3]
    else:
        codice = "".join(consonanti + vocali)[:3]
    return (codice + "XXX")[:3]

def _codice_data_sesso(d: date, sesso: str) -> str:
    yy = f"{d.year % 100:02d}"
    mm = MESE_CF[d.month]
    giorno = d.day + (40 if sesso.upper().startswith("F") else 0)
    gg = f"{giorno:02d}"
    return yy + mm + gg

def parse_data_it(data_str: str, campo: str = "Data"):
    """
    Prova a interpretare una data scritta in vari modi:
    - gg/mm/aaaa
    - gg-mm-aaaa
    - gg.mm.aaaa
    - gg mm aaaa

    Ritorna:
      - oggetto date se va bene
      - None se non riesce a interpretarla
    """
    if not data_str:
        return None

    s = data_str.strip()

    # unifichiamo i separatori a "/"
    for sep in ["-", ".", " "]:
        s = s.replace(sep, "/")

    # ora ci aspettiamo sempre gg/mm/aaaa
    try:
        d = datetime.strptime(s, "%d/%m/%Y").date()
        return d
    except ValueError:
        return None



def parse_data_it_to_iso(data_str: str, *, campo: str = "Data", min_year: int = 1900, max_year: int | None = None):
    """
    Valida una data in formato italiano (gg/mm/aaaa o con separatori - . spazio) e la converte in ISO (aaaa-mm-gg).
    Ritorna: (iso_str, err_msg)
      - se vuota -> (None, None)
      - se non valida -> (None, "messaggio errore")
    Non solleva eccezioni.
    """
    if data_str is None:
        return None, None
    s = str(data_str).strip()
    if not s:
        return None, None

    # unifica separatori
    for sep in ["-", ".", " "]:
        s = s.replace(sep, "/")

    # parsing
    try:
        d = datetime.strptime(s, "%d/%m/%Y").date()
    except ValueError:
        return None, f"{campo}: data non valida. Usa il formato gg/mm/aaaa (es. 25/01/2026)."

    today = date.today()
    if max_year is None:
        max_year = today.year + 1  # tolleranza: fino all'anno prossimo

    if d.year < min_year or d.year > max_year:
        return None, f"{campo}: anno non valido ({d.year}). Inserisci un anno tra {min_year} e {max_year}."

    # blocco âdate assurdeâ nel futuro (oltre 1 anno)
    if d > date(today.year + 1, 12, 31):
        return None, f"{campo}: data nel futuro non valida."

    return d.isoformat(), None
CODICI_CATASTALI_CSV = "codici_catastali_comuni.csv"

@lru_cache(maxsize=1)
def load_codici_catastali() -> Dict[tuple, str]:
    """
    Carica i codici catastali da codici_catastali_comuni.csv.

    Formato richiesto (con header):
    paese;prov;codice_catastale
    ABANO TERME;PD;A001
    ...
    """
    mapping: Dict[tuple, str] = {}
    if not os.path.exists(CODICI_CATASTALI_CSV):
        return mapping

    try:
        with open(CODICI_CATASTALI_CSV, "r", encoding="utf-8") as f:
            reader = csv.DictReader(f, delimiter=";")
            for row in reader:
                comune = (row.get("paese") or "").strip().upper()
                prov = (row.get("prov") or "").strip().upper()
                codice = (row.get("codice_catastale") or "").strip().upper()
                if comune and prov and codice:
                    mapping[(comune, prov)] = codice
    except Exception:
        # in caso di errore restituisce mappa vuota
        return {}

    return mapping


def _codice_catastale(comune: str, provincia: str) -> Optional[str]:
    """
    Ritorna il codice catastale leggendo dal CSV.

    comune: es. 'ABANO TERME'
    provincia: es. 'PD'
    """
    mapping = load_codici_catastali()
    key = (comune.strip().upper(), provincia.strip().upper())
    return mapping.get(key)



def _calcola_carattere_controllo(primi15: str) -> str:
    total = 0
    for i, ch in enumerate(primi15):
        if (i + 1) % 2 == 1:  # posizioni dispari (1-based)
            total += ODD_MAP.get(ch, 0)
        else:
            total += EVEN_MAP.get(ch, 0)
    resto = total % 26
    return CONTROL_CHARS[resto]

def genera_codice_fiscale(
    cognome: str,
    nome: str,
    data_nascita_str: str,
    sesso: str,
    comune_nascita: str,
    provincia_nascita: str,
) -> Optional[str]:
    """
    Genera un codice fiscale di supporto.
    Ritorna None se i dati non sono sufficienti/validi o se il comune non Ã¨ noto.
    """

    cognome = (cognome or "").strip()
    nome = (nome or "").strip()
    data_nascita_str = (data_nascita_str or "").strip()
    sesso = (sesso or "").strip()
    comune_nascita = (comune_nascita or "").strip()
    provincia_nascita = (provincia_nascita or "").strip()

    if not (cognome and nome and data_nascita_str and sesso and comune_nascita and provincia_nascita):
        return None

    try:
        d = datetime.strptime(data_nascita_str, "%d/%m/%Y").date()
    except ValueError:
        return None

    cod_cat = _codice_catastale(comune_nascita, provincia_nascita)
    if not cod_cat:
        return None

    parte1 = _codice_cognome(cognome)
    parte2 = _codice_nome(nome)
    parte3 = _codice_data_sesso(d, sesso)
    primi15 = (parte1 + parte2 + parte3 + cod_cat).upper()
    if len(primi15) != 15:
        return None

    controllo = _calcola_carattere_controllo(primi15)
    return primi15 + controllo

def valida_codice_fiscale(cf: str) -> bool:
    cf = (cf or "").strip().upper()
    if len(cf) != 16:
        return False
    if not cf.isalnum():
        return False
    primi15 = cf[:15]
    expected = _calcola_carattere_controllo(primi15)
    return cf[-1] == expected

# -----------------------------
# Helpers: Cheratometria & CL tools
# -----------------------------

def cherato_mm_to_D(raggio_mm: float) -> float:
    """
    Conversione approssimata raggio (mm) -> diottrie.
    Formula: D â 337.5 / r (mm)
    """
    if raggio_mm <= 0:
        return 0.0
    return 337.5 / raggio_mm

def cherato_D_to_mm(D: float) -> float:
    """
    Conversione approssimata diottrie -> raggio (mm).
    Formula: r (mm) â 337.5 / D
    """
    if D <= 0:
        return 0.0
    return 337.5 / D

def convert_occhiali_to_cl(sphere_glasses: float, cyl_glasses: float, axis: float, vertex_mm: float = 12.0):
    """
    Conversione approssimata occhiali -> lenti a contatto (sfera + cilindro).
    Usa la formula del potere efficace: F_cl = F_g / (1 - d * F_g), con d in metri.
    Calcola il potere in due meridiani e ricostruisce sfera e cilindro CL.
    """
    d = vertex_mm / 1000.0  # mm -> m
    F1 = sphere_glasses
    F2 = sphere_glasses + cyl_glasses

    def eff(F):
        return F / (1 - d * F) if (1 - d * F) != 0 else F

    F1c = eff(F1)
    F2c = eff(F2)

    sphere_cl = F1c
    cyl_cl = F2c - F1c

    # arrotonda a step 0.25
    sphere_cl = round(sphere_cl * 4) / 4.0
    cyl_cl = round(cyl_cl * 4) / 4.0
    axis_cl = axis  # asse invariato (approssimazione)

    return sphere_cl, cyl_cl, axis_cl

# -----------------------------
# Helpers: AcuitÃ  visiva (lista valori)
# -----------------------------

AV_OPTIONS = [
    "NV - non vedente",
    "PL - percezione luce",
    "ML/HM - moto mano",
    "CF 30 cm",
    "CF 50 cm",
    "CF 1 m",
    "1/50",
    "1/20",
    "1/10",
    "2/10",
    "3/10",
    "4/10",
    "5/10",
    "6/10",
    "7/10",
    "8/10",
    "9/10",
    "10/10",
    "12/10",
    "14/10",
    "16/10",
]

def av_select(label: str, current_value: Optional[str], key: str) -> str:
    """
    Selectbox per acuitÃ  visiva.
    Mantiene il valore salvato anche se non Ã¨ in AV_OPTIONS (lo mette in cima).
    """
    base = AV_OPTIONS.copy()
    if current_value and current_value not in base:
        options = [current_value] + base
    else:
        options = [""] + base
    index = 0
    if current_value and current_value in options:
        index = options.index(current_value)
    return st.selectbox(label, options, index=index, key=key)

# -----------------------------
# UI: Pazienti
# -----------------------------

def _format_data_it_from_iso(iso_str: Optional[str]) -> str:
    """
    Converte una data ISO (aaaa-mm-gg) in formato italiano gg/mm/aaaa.
    Se non valida, restituisce la stringa originale.
    """
    if not iso_str:
        return ""
    try:
        d = datetime.strptime(iso_str, "%Y-%m-%d").date()
        return d.strftime("%d/%m/%Y")
    except Exception:
        return iso_str


def row_get(row, key: str, default=None):
    """Safe getter for sqlite3.Row or dict."""
    if row is None:
        return default



def paziente_label(p):
    """Label paziente robusta: ID - Cognome Nome â CF (se presente)"""
    pid = row_get(p, "id", None)
    if pid is None:
        pid = row_get(p, "ID", "")
    cogn = (row_get(p, "cognome", "") or row_get(p, "Cognome", "") or "").strip()
    nome = (row_get(p, "nome", "") or row_get(p, "Nome", "") or "").strip()
    cf = (row_get(p, "codice_fiscale", "") or row_get(p, "Codice_Fiscale", "") or "").strip()

    base = f"{cogn} {nome}".strip()
    if not base:
        base = "(senza nome)"
    if cf:
        return f"{pid} - {base} â {cf}"
    return f"{pid} - {base}"

def extract_leading_int(label, default=None):
    """Estrae un ID numerico all'inizio di una stringa tipo '123 - Cognome Nome'.
    Ritorna default se non trova un numero.
    """
    s = "" if label is None else str(label)
    m = re.match(r"\s*(\d+)", s)
    return int(m.group(1)) if m else default
    try:
        if isinstance(row, dict):
            return row.get(key, default)
        if hasattr(row, "keys"):
            ks = row.keys()
            if key in ks:
                return row[key]
        # fallback
        return default
    except Exception:
        return default



def genera_referto_oculistico_pdf(paziente, valutazione, include_header: bool) -> bytes:
    """
    Genera un referto oculistico/optometrico in PDF A4.
    Usa solo i dati presenti in anagrafica + valutazione.
    """
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=A4)
    width, height = A4

    left = 30 * mm
    right = width - 30 * mm
    top = height - 30 * mm
    bottom = 30 * mm

    y = top

    # Intestazione opzionale (per carta intestata la puoi togliere)
    if include_header:
        c.setFont("Helvetica-Bold", 14)
        c.drawString(left, y, "Studio The Organism")
        y -= 14
        c.setFont("Helvetica", 10)
        c.drawString(left, y, "Via De Rosa 46 â Pagani (SA)")
        y -= 12
        c.drawString(left, y, "Tel: __________   Email: __________   Web: __________")
        y -= 20

    c.setFont("Helvetica-Bold", 12)
    c.drawString(left, y, "Referto oculistico / optometrico")
    y -= 20

    # Dati paziente
    c.setFont("Helvetica", 11)
    nome_paz = f"{row_get(paziente, "Cognome")} {row_get(paziente, "Nome")}"
    c.drawString(left, y, f"Paziente: {nome_paz}")
    y -= 14

    dn = _format_data_it_from_iso(row_get(paziente, "Data_Nascita"))
    if dn:
        c.drawString(left, y, f"Data di nascita: {dn}")
        y -= 14

    # Dati visita
    data_vis = _format_data_it_from_iso(row_get(valutazione, "Data_Valutazione"))
    if data_vis:
        c.drawString(left, y, f"Data visita: {data_vis}")
        y -= 14

    if row_get(valutazione, "Tipo_Visita"):
        c.drawString(left, y, f"Tipo visita: {row_get(valutazione, "Tipo_Visita")}")
        y -= 14

    if row_get(valutazione, "Professionista"):
        c.drawString(left, y, f"Professionista: {row_get(valutazione, "Professionista")}")
        y -= 18

    # --- Anamnesi (solo se presente) ---
    anam = (row_get(valutazione, "Anamnesi", "") or "").strip()
    if anam:
        c.setFont("Helvetica-Bold", 11)
        c.drawString(left, y, "Anamnesi")
        y -= 14
        c.setFont("Helvetica", 11)
        wrapper = textwrap.TextWrapper(width=90)
        for par in anam.split("\n"):
            par = par.strip()
            if not par:
                y -= 6
                continue
            for line in wrapper.wrap(par):
                if y < bottom + 40:
                    c.showPage()
                    c.setFont("Helvetica", 11)
                    y = top
                c.drawString(left, y, line)
                y -= 13
            y -= 3
        y -= 8

    # AcuitÃ  visiva solo se presenti
    av_lines = []
    if row_get(valutazione, "Acuita_Nat_OD") or row_get(valutazione, "Acuita_Nat_OS") or row_get(valutazione, "Acuita_Nat_OO"):
        av_lines.append(
            "AcuitÃ  visiva naturale: "
            f"OD {row_get(valutazione, "Acuita_Nat_OD") or '-'}   "
            f"OS {row_get(valutazione, "Acuita_Nat_OS") or '-'}   "
            f"OO {row_get(valutazione, "Acuita_Nat_OO") or '-'}"
        )
    if row_get(valutazione, "Acuita_Corr_OD") or row_get(valutazione, "Acuita_Corr_OS") or row_get(valutazione, "Acuita_Corr_OO"):
        av_lines.append(
            "AcuitÃ  visiva corretta: "
            f"OD {row_get(valutazione, "Acuita_Corr_OD") or '-'}   "
            f"OS {row_get(valutazione, "Acuita_Corr_OS") or '-'}   "
            f"OO {row_get(valutazione, "Acuita_Corr_OO") or '-'}"
        )

    c.setFont("Helvetica", 11)
    for line in av_lines:
        c.drawString(left, y, line)
        y -= 14
    if av_lines:
        y -= 6

    # Anamnesi (breve) se presente
    try:
        anam = row_get(valutazione, "Anamnesi") or ""
    except Exception:
        anam = ""
    if str(anam).strip():
        c.setFont("Helvetica-Bold", 11)
        c.drawString(left, y, "Anamnesi:")
        y -= 14
        c.setFont("Helvetica", 11)
        wrapper_a = textwrap.TextWrapper(width=90)
        for par in str(anam).split("\n"):
            par = par.strip()
            if not par:
                y -= 6
                continue
            for line in wrapper_a.wrap(par):
                if y < bottom + 40:
                    c.showPage()
                    c.setFont("Helvetica", 11)
                    y = top
                c.drawString(left, y, line)
                y -= 13
            y -= 4
        y -= 6

# Corpo del referto: stampa solo le sezioni valorizzate (Esame / Conclusioni).
    # Se il DB Ã¨ vecchio e non ha Esame/Conclusioni, ripiega su Note.
    esame = (row_get(valutazione, "Esame", "") or "").strip()
    concl = (row_get(valutazione, "Conclusioni", "") or "").strip()
    testo_legacy = (row_get(valutazione, "Note", "") or "").strip()

    def _draw_paragraph_block(title: str, text: str):
        nonlocal y
        if not text.strip():
            return
        c.setFont("Helvetica-Bold", 11)
        c.drawString(left, y, title)
        y -= 14
        c.setFont("Helvetica", 11)
        wrapper = textwrap.TextWrapper(width=90)
        for par in text.split("\n"):
            par = par.strip()
            if not par:
                y -= 6
                continue
            for line in wrapper.wrap(par):
                if y < bottom + 40:
                    c.showPage()
                    c.setFont("Helvetica", 11)
                    y = top
                c.drawString(left, y, line)
                y -= 13
            y -= 3
        y -= 8

    if esame or concl:
        _draw_paragraph_block("Esame / refertazione", esame)
        _draw_paragraph_block("Conclusioni / indicazioni", concl)
    elif testo_legacy:
        _draw_paragraph_block("Refertazione", testo_legacy)

    # Spazio firma

    if y < bottom + 60:
        c.showPage()
        c.setFont("Helvetica", 11)
        y = top

    y = bottom + 40
    c.line(right - 120, y, right, y)
    c.drawString(right - 110, y + 5, "Firma / Timbro")

    c.showPage()
    c.save()
    buffer.seek(0)
    return buffer.getvalue()

def genera_referto_oculistico_pdf_template(paziente, valutazione, mode: str = "LETTERHEAD") -> bytes:
    """
    Referto A4 con 3 modalitÃ :
    - mode="LETTERHEAD": solo contenuto clinico (per stampa su carta intestata fisica)
      -> parte ~3,4 cm dall'alto e lascia ~2,5 cm dal basso
    - mode="GRAPHIC_CIRILLO": include la grafica della carta intestata nel PDF (con nome medico).
    - mode="GRAPHIC_ORG": include la grafica The Organism ma senza blocco nome medico,
      e scrive il contenuto clinico nelle stesse coordinate utili.

    - mode="GRAPHIC": alias di GRAPHIC_CIRILLO (compatibilitÃ ).
      e scrive il contenuto clinico nelle stesse coordinate utili.

    Nota: stampa sempre e solo i campi valorizzati.
    """
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=A4)
    width, height = A4

    # Se includi grafica, disegnala subito come sfondo
    m = (mode or "").upper()
    if m.startswith("GRAPHIC"):
        variant = "CIRILLO" if m in ("GRAPHIC", "GRAPHIC_CIRILLO") else "ORG_ONLY"
        draw_letterhead_background(c, pagesize=A4, variant=variant)

    # Margini richiesti (carta intestata): 3,4 cm dall'alto e 2,5 cm dal basso
    left = 25 * mm
    right = width - 25 * mm
    top = height - 36 * mm   # 3,4 cm
    bottom = 25 * mm         # 2,5 cm

    y = top

    # Data referto
    data_iso = (row_get(valutazione, "Data_Valutazione") if isinstance(valutazione, sqlite3.Row) else valutazione.get("Data_Valutazione"))
    data_it = _format_data_it_from_iso(data_iso) if data_iso else ""
    c.setFont("Helvetica", 10)
    if data_it:
        c.drawRightString(right, y, f"Data referto: {data_it}")
    y -= 18

    # Titolo
    c.setFont("Helvetica-Bold", 13)
    c.drawString(left, y, "Referto oculistico / optometrico")
    y -= 16

    # Dati paziente
    c.setFont("Helvetica", 10.5)
    cogn = row_get(paziente, "Cognome") if isinstance(paziente, sqlite3.Row) else paziente.get("Cognome", "")
    nome = row_get(paziente, "Nome") if isinstance(paziente, sqlite3.Row) else paziente.get("Nome", "")
    nome_paz = f"{(cogn or '').strip()} {(nome or '').strip()}".strip()
    if nome_paz:
        c.drawString(left, y, f"Paziente: {nome_paz}")
        y -= 12

    dn = row_get(paziente, "Data_Nascita") if isinstance(paziente, sqlite3.Row) else paziente.get("Data_Nascita")
    cf = (row_get(paziente, "Codice_Fiscale") if isinstance(paziente, sqlite3.Row) else paziente.get("Codice_Fiscale")) or ""
    extra_parts = []
    if dn:
        extra_parts.append(f"Nato il: {_format_data_it_from_iso(dn)}")
    if cf:
        extra_parts.append(f"CF: {str(cf).upper()}")
    if extra_parts:
        c.drawString(left, y, " â ".join(extra_parts))
        y -= 12

    tipo = row_get(valutazione, "Tipo_Visita") if isinstance(valutazione, sqlite3.Row) else valutazione.get("Tipo_Visita")
    prof = row_get(valutazione, "Professionista") if isinstance(valutazione, sqlite3.Row) else valutazione.get("Professionista")
    if tipo:
        c.drawString(left, y, f"Tipo visita: {tipo}")
        y -= 12
    if prof:
        c.drawString(left, y, f"Professionista: {prof}")
        y -= 14

    # Blocchi clinici strutturati (se presenti)
    def _v(k):
        return (valutazione[k] if isinstance(valutazione, sqlite3.Row) and k in valutazione.keys() else (valutazione.get(k) if isinstance(valutazione, dict) else None))

    anam = (str(_v("Anamnesi") or "").strip())
    esame = (str(_v("Esame") or "").strip())
    concl = (str(_v("Conclusioni") or "").strip())
    note_int = (str(_v("Note_Interne") or "").strip())

    # AcuitÃ 
    ac_nat_od = str(_v("Acuita_Nat_OD") or "").strip()
    ac_nat_os = str(_v("Acuita_Nat_OS") or "").strip()
    ac_nat_oo = str(_v("Acuita_Nat_OO") or "").strip()
    ac_cor_od = str(_v("Acuita_Corr_OD") or "").strip()
    ac_cor_os = str(_v("Acuita_Corr_OS") or "").strip()
    ac_cor_oo = str(_v("Acuita_Corr_OO") or "").strip()

    def write_block(title: str, body: str):
        nonlocal y
        if not body.strip():
            return
        c.setFont("Helvetica-Bold", 10.8)
        c.drawString(left, y, title)
        y -= 12
        c.setFont("Helvetica", 10)
        wrapper = textwrap.TextWrapper(width=92)
        for paragraph in body.split("\n"):
            paragraph = paragraph.strip()
            if not paragraph:
                y -= 4
                continue
            for line in wrapper.wrap(paragraph):
                if y < bottom + 45:
                    c.showPage()
                    if mode.upper() == "GRAPHIC":
                        draw_letterhead_background(c, pagesize=A4)
                    y = top
                    c.setFont("Helvetica", 10)
                c.drawString(left, y, line)
                y -= 12
        y -= 6

    # Anamnesi prima di tutto (come richiesto)
    write_block("Anamnesi", anam)

    # AcuitÃ  visiva
    if any([ac_nat_od, ac_nat_os, ac_nat_oo, ac_cor_od, ac_cor_os, ac_cor_oo]):
        c.setFont("Helvetica-Bold", 10.8)
        c.drawString(left, y, "AcuitÃ  visiva")
        y -= 12
        c.setFont("Helvetica", 10)

        if any([ac_nat_od, ac_nat_os, ac_nat_oo]):
            parts = []
            if ac_nat_od: parts.append(f"OD {ac_nat_od}")
            if ac_nat_os: parts.append(f"OS {ac_nat_os}")
            if ac_nat_oo: parts.append(f"OO {ac_nat_oo}")
            c.drawString(left + 10, y, "Naturale: " + " â ".join(parts))
            y -= 12

        if any([ac_cor_od, ac_cor_os, ac_cor_oo]):
            parts = []
            if ac_cor_od: parts.append(f"OD {ac_cor_od}")
            if ac_cor_os: parts.append(f"OS {ac_cor_os}")
            if ac_cor_oo: parts.append(f"OO {ac_cor_oo}")
            c.drawString(left + 10, y, "Corretta: " + " â ".join(parts))
            y -= 14

        y -= 4

    # Esame e conclusioni
    write_block("Esame e refertazione", esame)
    write_block("Conclusioni / indicazioni", concl)

    # Fallback legacy: se esame+conclusioni vuoti, usa Note vecchie
    if not esame and not concl:
        legacy = str(_v("Note") or "").strip()
        if legacy:
            write_block("Esame e refertazione", legacy)

    # Firma (sempre dentro margini utili)
    if y < bottom + 60:
        c.showPage()
        if mode.upper() == "GRAPHIC":
            draw_letterhead_background(c, pagesize=A4)
        y = top

    c.setFont("Helvetica", 10)
    c.drawRightString(right, bottom + 40, "_____________________________")
    c.drawRightString(right, bottom + 26, "Firma / Timbro")

    c.showPage()
    c.save()
    buffer.seek(0)
    return buffer.getvalue()

def draw_axis_arrow(c, center_x, center_y, radius, axis_deg: int):
    """
    Disegna una freccia sulla semicirconferenza per indicare l'asse (0â180Â°).
    0Â° = lato destro, 90Â° = alto, 180Â° = sinistra.
    """
    axis_deg = max(0, min(180, int(axis_deg)))  # clamp di sicurezza
    angle_rad = math.radians(axis_deg)

    # Punto interno e punto sulla circonferenza
    r1 = radius * 0.7
    r2 = radius * 0.95
    x1 = center_x + r1 * math.cos(angle_rad)
    y1 = center_y + r1 * math.sin(angle_rad)
    x2 = center_x + r2 * math.cos(angle_rad)
    y2 = center_y + r2 * math.sin(angle_rad)

    c.setLineWidth(1)
    # stelo della freccia
    c.line(x1, y1, x2, y2)

    # testa della freccia (due segmentini inclinati)
    head_len = radius * 0.15
    for delta in (-20, 20):
        ang = angle_rad + math.radians(delta)
        hx = x2 - head_len * math.cos(ang)
        hy = y2 - head_len * math.sin(ang)
        c.line(x2, y2, hx, hy)

def draw_axis_arrow(c, center_x, center_y, radius, axis_deg: int):
    """
    Disegna una freccia sulla semicirconferenza per indicare l'asse (0â180Â°).
    0Â° = lato destro, 90Â° = alto, 180Â° = sinistra.
    """
    axis_deg = max(0, min(180, int(axis_deg)))  # clamp di sicurezza
    angle_rad = math.radians(axis_deg)

    # Punto interno e punto sulla circonferenza
    r1 = radius * 0.7
    r2 = radius * 0.95
    x1 = center_x + r1 * math.cos(angle_rad)
    y1 = center_y + r1 * math.sin(angle_rad)
    x2 = center_x + r2 * math.cos(angle_rad)
    y2 = center_y + r2 * math.sin(angle_rad)

    c.setLineWidth(1)
    # stelo della freccia
    c.line(x1, y1, x2, y2)

    # testa della freccia (due segmentini inclinati)
    head_len = radius * 0.15
    for delta in (-20, 20):
        ang = angle_rad + math.radians(delta)
        hx = x2 - head_len * math.cos(ang)
        hy = y2 - head_len * math.sin(ang)
        c.line(x2, y2, hx, hy)


def genera_prescrizione_occhiali_a5_pdf(
    paziente,
    data_prescrizione_iso: Optional[str],
    sf_lon_od: float, cil_lon_od: float, ax_lon_od: int,
    sf_lon_os: float, cil_lon_os: float, ax_lon_os: int,
    sf_int_od: float, cil_int_od: float, ax_int_od: int,
    sf_int_os: float, cil_int_os: float, ax_int_os: int,
    sf_vic_od: float, cil_vic_od: float, ax_vic_od: int,
    sf_vic_os: float, cil_vic_os: float, ax_vic_os: int,
    lenti_scelte: list,
    altri_trattamenti: str,
    note: str,
    template_mode: str = "CIRILLO",
) -> bytes:
    """
    Genera una prescrizione occhiali in formato A5 con:
    - margini 3 cm alto/basso, 2 cm dx/sn
    - data in alto a destra
    - nome paziente
    - due semicerchi con gradi (schema TABO semplificato) + freccia dell'asse di LONTANO
    - tre righe LONTANO / INTERMEDIO / VICINO (SF, CIL, AX per OD/OS)
    - lenti consigliate (check)
    - campo note
    """
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=A5)
    width, height = A5

    # Template grafico (carta intestata) per A5:
    # - avvio contenuto ~3,4 cm dall'alto
    # - lascia ~2,5 cm dal basso
    left = 20 * mm
    right = width - 20 * mm

    m = (template_mode or "").upper()
    if m in ("CIRILLO", "ORG_ONLY", "ORG", "GRAPHIC_CIRILLO", "GRAPHIC_ORG"):
        variant = "CIRILLO" if m in ("CIRILLO", "GRAPHIC_CIRILLO") else "ORG_ONLY"
        draw_letterhead_background(c, pagesize=A5, variant=variant)
        top = height - 36 * mm
        bottom = 25 * mm
    else:
        top = height - 30 * mm
        bottom = 30 * mm

    # Data prescrizione
    c.setFont("Helvetica", 10)
    data_it = _format_data_it_from_iso(data_prescrizione_iso) if data_prescrizione_iso else ""
    if data_it:
        c.drawRightString(right, top, f"Data: {data_it}")

    # Nome paziente
    y = top - 15
    c.setFont("Helvetica-Bold", 11)
    nome_paz = f"{row_get(paziente, "Cognome")} {row_get(paziente, "Nome")}"
    c.drawString(left, y, f"Paziente: {nome_paz}")
    y -= 20

    # Semicerchi TABO semplificati per OD e OS
    c.setFont("Helvetica", 8)
    radius = 22 * mm
    center_y = y - radius - 5 * mm
    center_x_os = left + radius
    center_x_od = right - radius

    # OS â semicirconferenza + etichette
    c.arc(
        center_x_os - radius,
        center_y - radius,
        center_x_os + radius,
        center_y + radius,
        0,
        180,
    )
    c.drawString(center_x_os - radius - 4 * mm, center_y, "180Â° / 0Â°")
    c.drawString(center_x_os - 5, center_y + radius + 3 * mm, "90Â°")

    # OD â semicirconferenza + etichette
    c.arc(
        center_x_od - radius,
        center_y - radius,
        center_x_od + radius,
        center_y + radius,
        0,
        180,
    )
    c.drawString(center_x_od - radius - 4 * mm, center_y, "180Â° / 0Â°")
    c.drawString(center_x_od - 5, center_y + radius + 3 * mm, "90Â°")

    # Frecce sull'asse (uso gli assi di LONTANO: ax_lon_os / ax_lon_od)
    try:
        draw_axis_arrow(c, center_x_os, center_y, radius, ax_lon_os)
        draw_axis_arrow(c, center_x_od, center_y, radius, ax_lon_od)
    except Exception:
        # se per qualunque motivo qualcosa va storto, non blocchiamo la prescrizione
        pass

    y = center_y - radius - 10

    # Funzione di utilitÃ  per disegnare una riga LONTANO/INTERMEDIO/VICINO
    def draw_riga_prescr(y_start, label, sf_od, cil_od, ax_od, sf_os, cil_os, ax_os):
        # se tutti zero, saltiamo la riga
        if (
            abs(sf_od) < 0.001 and abs(cil_od) < 0.001 and int(ax_od) == 0 and
            abs(sf_os) < 0.001 and abs(cil_os) < 0.001 and int(ax_os) == 0
        ):
            return y_start

        c.setFont("Helvetica-Bold", 9)
        c.drawString(left, y_start, label)
        y = y_start - 11
        c.setFont("Helvetica", 9)
        c.drawString(
            left + 5 * mm,
            y,
            f"OD: SF {sf_od:+.2f}  CIL {cil_od:+.2f}  AX {int(ax_od)}Â°",
        )
        y -= 10
        c.drawString(
            left + 5 * mm,
            y,
            f"OS: SF {sf_os:+.2f}  CIL {cil_os:+.2f}  AX {int(ax_os)}Â°",
        )
        return y - 8

    y = draw_riga_prescr(y, "LONTANO", sf_lon_od, cil_lon_od, ax_lon_od, sf_lon_os, cil_lon_os, ax_lon_os)
    y = draw_riga_prescr(y, "INTERMEDIO", sf_int_od, cil_int_od, ax_int_od, sf_int_os, cil_int_os, ax_int_os)
    y = draw_riga_prescr(y, "VICINO", sf_vic_od, cil_vic_od, ax_vic_od, sf_vic_os, cil_vic_os, ax_vic_os)

    y -= 5

    # Lenti consigliate
    c.setFont("Helvetica-Bold", 9)
    c.drawString(left, y, "Lenti consigliate:")
    y -= 12
    c.setFont("Helvetica", 9)

    tutte_lenti = [
        "Progressive",
        "Per vicino/intermedio",
        "Fotocromatiche",
        "Polarizzate",
        "Controllo miopia",
        "Trattamento antiriflesso",
    ]

    for voce in tutte_lenti:
        mark = "[x]" if voce in lenti_scelte else "[ ]"
        c.drawString(left + 5 * mm, y, f"{mark} {voce}")
        y -= 10

    if altri_trattamenti:
        c.drawString(left + 5 * mm, y, f"Altri trattamenti: {altri_trattamenti}")
        y -= 12

    # Note
    if note.strip():
        c.setFont("Helvetica-Bold", 9)
        c.drawString(left, y, "Note:")
        y -= 10
        c.setFont("Helvetica", 9)
        wrapper = textwrap.TextWrapper(width=70)
        for line in wrapper.wrap(note.strip()):
            if y < bottom + 40:
                c.showPage()
                c.setFont("Helvetica", 9)
                y = top
            c.drawString(left + 5 * mm, y, line)
            y -= 11

    # Firma
    if y < bottom + 50:
        c.showPage()
        c.setFont("Helvetica", 9)
        y = top

    c.line(right - 100, bottom + 30, right, bottom + 30)
    c.drawString(right - 95, bottom + 35, "Firma / Timbro")

    c.showPage()
    c.save()
    buffer.seek(0)
    return buffer.getvalue()
def genera_referto_oculistico_a4_pdf(paziente, valutazione, with_header: bool) -> bytes:
    """
    Genera un referto oculistico/optometrico in formato A4.
    - with_header = True  â stampa anche l'intestazione dello studio
    - with_header = False â niente intestazione (usa carta intestata)
    Stampa solo i campi realmente compilati (non vuoti).
    """
    buffer = io.BytesIO()
    c = canvas.Canvas(buffer, pagesize=A4)
    width, height = A4

    left = 25 * mm
    right = width - 25 * mm

    # Margini per carta intestata: 3,4 cm dall'alto e 2,5 cm dal basso
    top = height - (27 * mm if with_header else 36 * mm)
    bottom = 25 * mm

    y = top

    # Intestazione opzionale
    if with_header:
        c.setFont("Helvetica-Bold", 12)
        c.drawCentredString(width / 2.0, y, "The Organism â Centro di Neuropsicologia e Sviluppo")
        y -= 14
        c.setFont("Helvetica", 9)
        c.drawCentredString(width / 2.0, y, "Via De Rosa, 46 â 84016 Pagani (SA)")
        y -= 18

    # Data referto = data valutazione
    data_iso = row_get(valutazione, "Data_Valutazione")
    data_it = _format_data_it_from_iso(data_iso) if data_iso else ""
    c.setFont("Helvetica", 10)
    if data_it:
        c.drawRightString(right, y, f"Data referto: {data_it}")
    y -= 20

    # Titolo
    c.setFont("Helvetica-Bold", 14)
    c.drawString(left, y, "Referto oculistico / optometrico")
    y -= 20

    # Dati paziente
    c.setFont("Helvetica", 11)
    nome_paz = f"{row_get(paziente, "Cognome")} {row_get(paziente, "Nome")}"
    c.drawString(left, y, f"Paziente: {nome_paz}")
    y -= 14

    # Data nascita + CF se presenti
    dn = row_get(paziente, "Data_Nascita")
    cf = (row_get(paziente, "Codice_Fiscale") or "").upper() if row_get(paziente, "Codice_Fiscale") else ""
    extra_parts = []
    if dn:
        try:
            dn_it = _format_data_it_from_iso(dn)
        except Exception:
            dn_it = dn
        extra_parts.append(f"Nato il: {dn_it}")
    if cf:
        extra_parts.append(f"CF: {cf}")
    if extra_parts:
        c.setFont("Helvetica", 10)
        c.drawString(left, y, " â ".join(extra_parts))
        y -= 14

    # Tipo visita e professionista
    tipo = row_get(valutazione, "Tipo_Visita") or ""
    prof = row_get(valutazione, "Professionista") or ""
    if tipo:
        c.drawString(left, y, f"Tipo visita: {tipo}")
        y -= 14
    if prof:
        c.drawString(left, y, f"Professionista: {prof}")
        y -= 18

    # Blocco ANAMNESI (breve) se presente
    try:
        anam = row_get(valutazione, "Anamnesi") or ""
    except Exception:
        anam = ""
    if str(anam).strip():
        c.setFont("Helvetica-Bold", 10)
        c.drawString(left, y, "Anamnesi:")
        y -= 12
        c.setFont("Helvetica", 10)
        wrapper_a = textwrap.TextWrapper(width=95)
        for par in str(anam).split("\n"):
            par = par.strip()
            if not par:
                y -= 6
                continue
            for line in wrapper_a.wrap(par):
                if y < bottom + 45:
                    c.showPage()
                    y = top
                    if with_header:
                        c.setFont("Helvetica-Bold", 12)
                        c.drawCentredString(width / 2.0, y, "The Organism â Centro di Neuropsicologia e Sviluppo")
                        y -= 14
                        c.setFont("Helvetica", 9)
                        c.drawCentredString(width / 2.0, y, "Via De Rosa, 46 â 84016 Pagani (SA)")
                        y -= 18
                    c.setFont("Helvetica", 10)
                c.drawString(left + 5 * mm, y, line)
                y -= 11
        y -= 10

    

    # AcuitÃ  visiva (stampata solo se Ã¨ stato scritto qualcosa)
    ac_nat_od = row_get(valutazione, "Acuita_Nat_OD") or ""
    ac_nat_os = row_get(valutazione, "Acuita_Nat_OS") or ""
    ac_nat_oo = row_get(valutazione, "Acuita_Nat_OO") or ""
    ac_cor_od = row_get(valutazione, "Acuita_Corr_OD") or ""
    ac_cor_os = row_get(valutazione, "Acuita_Corr_OS") or ""
    ac_cor_oo = row_get(valutazione, "Acuita_Corr_OO") or ""

    if any([ac_nat_od, ac_nat_os, ac_nat_oo, ac_cor_od, ac_cor_os, ac_cor_oo]):
        c.setFont("Helvetica-Bold", 11)
        c.drawString(left, y, "AcuitÃ  visiva")
        y -= 14
        c.setFont("Helvetica", 10)

        if any([ac_nat_od, ac_nat_os, ac_nat_oo]):
            parts = []
            if ac_nat_od:
                parts.append(f"OD {ac_nat_od}")
            if ac_nat_os:
                parts.append(f"OS {ac_nat_os}")
            if ac_nat_oo:
                parts.append(f"OO {ac_nat_oo}")
            c.drawString(left + 10, y, "Naturale: " + " â ".join(parts))
            y -= 12

        if any([ac_cor_od, ac_cor_os, ac_cor_oo]):
            parts = []
            if ac_cor_od:
                parts.append(f"OD {ac_cor_od}")
            if ac_cor_os:
                parts.append(f"OS {ac_cor_os}")
            if ac_cor_oo:
                parts.append(f"OO {ac_cor_oo}")
            c.drawString(left + 10, y, "Corretta: " + " â ".join(parts))
            y -= 16

    # Blocco NOTE / refertazione
    note = row_get(valutazione, "Note") or ""
    if note.strip():
        c.setFont("Helvetica-Bold", 11)
        c.drawString(left, y, "Esame e refertazione")
        y -= 14
        c.setFont("Helvetica", 10)

        wrapper = textwrap.TextWrapper(width=90)
        for paragraph in note.split("\n"):
            paragraph = paragraph.strip()
            if not paragraph:
                y -= 6
                continue
            for line in wrapper.wrap(paragraph):
                if y < bottom + 50:
                    c.showPage()
                    y = top
                    if with_header:
                        c.setFont("Helvetica-Bold", 12)
                        c.drawCentredString(width / 2.0, y, "The Organism â Centro di Neuropsicologia e Sviluppo")
                        y -= 14
                        c.setFont("Helvetica", 9)
                        c.drawCentredString(width / 2.0, y, "Via De Rosa, 46 â 84016 Pagani (SA)")
                        y -= 18
                        c.setFont("Helvetica", 10)
                c.drawString(left, y, line)
                y -= 12

    # Spazio firma
    if y < bottom + 60:
        c.showPage()
        y = top

    c.setFont("Helvetica", 10)
    c.drawRightString(right, bottom + 40, "_____________________________")
    c.drawRightString(right, bottom + 26, "Firma / Timbro")

    c.showPage()
    c.save()
    buffer.seek(0)
    return buffer.getvalue()


def ui_pazienti():
    st.header("Pazienti")

    # --- Export Excel (lista pazienti) ---
    with st.expander("Export pazienti (Excel)"):
        if not OPENPYXL_AVAILABLE:
            st.info("Per esportare in Excel installa 'openpyxl' (pip install openpyxl).")
        else:
            include_arch = st.checkbox("Includi anche pazienti ARCHIVIATI", value=False, key="xlsx_include_arch")
            if st.button("Genera Excel pazienti", key="btn_xlsx_paz"):
                try:
                    xlsx_bytes = export_pazienti_excel(include_archiviati=include_arch)
                    st.download_button(
                        "Scarica Excel pazienti",
                        data=xlsx_bytes,
                        file_name="pazienti_the_organism.xlsx",
                        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                        key="dl_pazienti_xlsx",
                    )
                except Exception as e:
                    st.error(f"Errore export Excel: {e}")

    conn = get_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)

    # --- Tool CF separato (facoltativo) ---
    with st.expander("Tool di supporto per generare il Codice Fiscale"):
        st.write("Usalo come aiuto quando il paziente non ricorda il CF. Copia il risultato nel campo CF dell'anagrafica.")
        with st.form("cf_tool"):
            cogn_t = st.text_input("Cognome", key="cf_cognome")
            nome_t = st.text_input("Nome", key="cf_nome")
            data_t = st.text_input("Data di nascita (gg/mm/aaaa)", key="cf_data")
            sesso_t = st.selectbox("Sesso", ["", "M", "F", "Altro"], key="cf_sesso")
            comune_n_t = st.text_input("Comune di nascita (es. Pagani)", key="cf_comune")
            prov_n_t = st.text_input("Provincia di nascita (sigla, es. SA)", key="cf_prov")
            calcola = st.form_submit_button("Calcola CF")
            if calcola:
                cf_gen = genera_codice_fiscale(
                    cognome=cogn_t,
                    nome=nome_t,
                    data_nascita_str=data_t,
                    sesso=sesso_t,
                    comune_nascita=comune_n_t,
                    provincia_nascita=prov_n_t,
                )
                if cf_gen is None:
                    st.error(
                        "Impossibile generare il codice fiscale: controlla i dati e che il comune sia previsto nel file dei codici catastali."
                    )
                else:
                    st.success(f"Codice fiscale generato: **{cf_gen}**")
                    st.info("Copia questo codice nel campo 'Codice fiscale' del paziente.")

    st.markdown("---")
    st.subheader("Nuovo paziente")

    # --- Nuovo paziente ---
    with st.form("nuovo_paziente"):
        col1, col2 = st.columns(2)
        with col1:
            cognome = st.text_input("Cognome", "")
            data_nascita_str = st.text_input("Data di nascita (gg/mm/aaaa)", "")
        with col2:
            nome = st.text_input("Nome", "")
            sesso = st.selectbox("Sesso", ["", "M", "F", "Altro"])

        col3, col4, col5 = st.columns(3)
        with col3:
            indirizzo = st.text_input("Indirizzo (via, numero civico)", "")
        with col4:
            cap = st.text_input("CAP", "")
        with col5:
            provincia = st.text_input("Provincia (sigla, es. SA)", "")

        col6, col7 = st.columns(2)
        with col6:
            citta = st.text_input("CittÃ  / Comune di residenza", "")
        with col7:
            codice_fiscale = st.text_input("Codice fiscale", "").upper()

        col8, col9 = st.columns(2)
        with col8:
            telefono = st.text_input("Telefono", "")
        with col9:
            email = st.text_input("Email", "")

        salva = st.form_submit_button("Salva paziente")

    # --- Salvataggio nuovo paziente ---
    if salva:
        if not cognome or not nome:
            st.error("Cognome e Nome sono obbligatori.")
        else:
            # Gestione data di nascita (formato gg/mm/aaaa)
            data_iso, err = parse_data_it_to_iso(
                data_nascita_str,
                campo="Data di nascita",
                min_year=1900,
                max_year=date.today().year  # nascita non nel futuro
            )
            if err:
                st.error(err)
                conn.close()
                return

            # Codice fiscale (opzionale) con controllo
            cf_clean = (codice_fiscale or "").strip().upper()
            if cf_clean and not valida_codice_fiscale(cf_clean):
                st.warning(
                    "Il codice fiscale inserito non sembra valido rispetto all'algoritmo di controllo. "
                    "Puoi comunque salvarlo, ma verifica con attenzione."
                )

            cur.execute(
                """
                INSERT INTO Pazienti
                (Cognome, Nome, Data_Nascita, Sesso, Telefono, Email,
                 Indirizzo, CAP, Citta, Provincia, Codice_Fiscale, Stato_Paziente)
                VALUES (?,?,?,?,?,?,?,?,?,?,?,?)
                """,
                (
                    cognome.strip(),
                    nome.strip(),
                    data_iso,
                    sesso,
                    telefono.strip(),
                    email.strip(),
                    indirizzo.strip(),
                    cap.strip(),
                    citta.strip(),
                    provincia.strip().upper(),
                    cf_clean or None,
                    "ATTIVO",
                ),
            )
            conn.commit()
            st.success("Paziente salvato correttamente.")

    st.markdown("---")
    st.subheader("Elenco pazienti")

    # Filtro ricerca
    filtro = st.text_input("Cerca per cognome/nome/codice fiscale", "")

    query = "SELECT * FROM Pazienti"
    params = []
    if filtro.strip():
        query += " WHERE Cognome LIKE ? OR Nome LIKE ? OR Codice_Fiscale LIKE ?"
        like = f"%{filtro.strip()}%"
        params = [like, like, like]
    query += " ORDER BY Cognome, Nome"

    cur.execute(query, params)
    rows = cur.fetchall()

    if not rows:
        st.info("Nessun paziente trovato.")
        conn.close()
        return

    # Etichette ricche: ID + Cognome Nome + data nascita + CF
    options = []
    for r in rows:
        nascita_it = ""
        if row_get(r, "Data_Nascita"):
            try:
                nascita_it = datetime.strptime(row_get(r, "Data_Nascita"), "%Y-%m-%d").strftime("%d/%m/%Y")
            except Exception:
                nascita_it = row_get(r, "Data_Nascita")
        cf = (row_get(r, "Codice_Fiscale") or "").upper()
        label = f"{row_get(r, "ID")} - {row_get(r, "Cognome")} {row_get(r, "Nome")}"
        extra = []
        if nascita_it:
            extra.append(f"nato il {nascita_it}")
        if cf:
            extra.append(f"CF: {cf}")
        if extra:
            label += " (" + " | ".join(extra) + ")"
        options.append(label)

    selected = st.selectbox("Seleziona un paziente per modificare / archiviare", options)
        # Robust selezione ID (gestisce label non standard / None)
    sel_id = None
    try:
        sel_id = int(str(selected).split(" - ", 1)[0].strip())
    except Exception:
        m = re.match(r"\s*(\d+)", str(selected))
        if m:
            sel_id = int(m.group(1))

    rec = next(r for r in rows if row_get(r, "ID") == sel_id)

    st.write(f"Stato attuale: **{row_get(rec, "Stato_Paziente")}**")

    col_a, col_b, col_c = st.columns(3)
    with col_a:
        if st.button("Archivia paziente", key="archivia"):
            cur.execute("UPDATE Pazienti SET Stato_Paziente = 'ARCHIVIATO' WHERE ID = ?", (sel_id,))
            conn.commit()
            st.success("Paziente archiviato.")
            st.experimental_rerun() if hasattr(st, "experimental_rerun") else st.rerun()
    with col_b:
        if st.button("Riattiva paziente", key="riattiva"):
            cur.execute("UPDATE Pazienti SET Stato_Paziente = 'ATTIVO' WHERE ID = ?", (sel_id,))
            conn.commit()
            st.success("Paziente riattivato.")
            st.experimental_rerun() if hasattr(st, "experimental_rerun") else st.rerun()
    with col_c:
        if st.button("Elimina definitivamente", key="elimina"):
            cur.execute("DELETE FROM Anamnesi WHERE Paziente_ID = ?", (sel_id,))
            cur.execute("DELETE FROM Valutazioni_Visive WHERE Paziente_ID = ?", (sel_id,))
            cur.execute("DELETE FROM Sedute WHERE Paziente_ID = ?", (sel_id,))
            cur.execute("DELETE FROM Coupons WHERE Paziente_ID = ?", (sel_id,))
            cur.execute("DELETE FROM Pazienti WHERE ID = ?", (sel_id,))
            conn.commit()
            st.success("Paziente e dati associati eliminati.")
            conn.close()
            st.stop()

    st.markdown("### Modifica dati paziente")
    with st.form("modifica_paziente"):
        col1, col2 = st.columns(2)
        with col1:
            cognome_m = st.text_input("Cognome", row_get(rec, "Cognome") or "", key="m_cognome")
            data_nascita_m = st.text_input(
                "Data di nascita (gg/mm/aaaa)",
                datetime.strptime(row_get(rec, "Data_Nascita"), "%Y-%m-%d").strftime("%d/%m/%Y")
                if row_get(rec, "Data_Nascita") else "",
                key="m_data_nascita",
            )
        with col2:
            nome_m = st.text_input("Nome", row_get(rec, "Nome") or "", key="m_nome")
            sesso_m = st.selectbox(
                "Sesso",
                ["", "M", "F", "Altro"],
                index=(["", "M", "F", "Altro"].index(row_get(rec, "Sesso")) if row_get(rec, "Sesso") in ["", "M", "F", "Altro"] else 0),
                key="m_sesso",
            )

        col3, col4, col5 = st.columns(3)
        with col3:
            indirizzo_m = st.text_input("Indirizzo", row_get(rec, "Indirizzo") or "", key="m_indirizzo")
        with col4:
            cap_m = st.text_input("CAP", row_get(rec, "CAP") or "", key="m_cap")
        with col5:
            provincia_m = st.text_input("Provincia", row_get(rec, "Provincia") or "", key="m_provincia")

        col6, col7 = st.columns(2)
        with col6:
            citta_m = st.text_input("CittÃ ", row_get(rec, "Citta") or "", key="m_citta")
        with col7:
            cf_m = st.text_input("Codice fiscale", (row_get(rec, "Codice_Fiscale") or "").upper(), key="m_cf")

        col8, col9 = st.columns(2)
        with col8:
            telefono_m = st.text_input("Telefono", row_get(rec, "Telefono") or "", key="m_tel")
        with col9:
            email_m = st.text_input("Email", row_get(rec, "Email") or "", key="m_email")

        stato_m = st.selectbox(
            "Stato paziente",
            ["ATTIVO", "ARCHIVIATO"],
            index=(0 if (row_get(rec, "Stato_Paziente") or "ATTIVO") == "ATTIVO" else 1),
            key="m_stato",
        )

        salva_mod = st.form_submit_button("Salva modifiche")

    if salva_mod:
        if not cognome_m or not nome_m:
            st.error("Cognome e Nome sono obbligatori.")
        else:
            data_iso_m, err = parse_data_it_to_iso(
                data_nascita_m,
                campo="Data di nascita",
                min_year=1900,
                max_year=date.today().year
            )
            if err:
                st.error(err)
                conn.close()
                return

            cf_clean_m = (cf_m or "").strip().upper()
            if cf_clean_m and not valida_codice_fiscale(cf_clean_m):
                st.warning(
                    "Il codice fiscale inserito non sembra valido rispetto all'algoritmo di controllo. "
                    "Puoi comunque salvarlo, ma verifica con attenzione."
                )

            cur.execute(
                """
                UPDATE Pazienti
                SET Cognome = ?, Nome = ?, Data_Nascita = ?, Sesso = ?,
                    Telefono = ?, Email = ?, Indirizzo = ?, CAP = ?, Citta = ?, Provincia = ?,
                    Codice_Fiscale = ?, Stato_Paziente = ?
                WHERE ID = ?
                """,
                (
                    cognome_m.strip(),
                    nome_m.strip(),
                    data_iso_m,
                    sesso_m,
                    telefono_m.strip(),
                    email_m.strip(),
                    indirizzo_m.strip(),
                    cap_m.strip(),
                    citta_m.strip(),
                    provincia_m.strip().upper(),
                    cf_clean_m or None,
                    stato_m,
                    sel_id,
                ),
            )
            conn.commit()
            st.success("Dati paziente aggiornati.")

    conn.close()



# -----------------------------
# UI: Anamnesi
# -----------------------------

def ui_anamnesi():
    st.header("Anamnesi")

    conn = get_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)

    # Seleziona paziente
    cur.execute("SELECT ID, Cognome, Nome FROM Pazienti ORDER BY Cognome, Nome")
    pazienti = cur.fetchall()
    if not pazienti:
        st.info("Nessun paziente registrato.")
        conn.close()
        return

    options = [paziente_label(p) for p in pazienti]
    sel = st.selectbox("Seleziona paziente", options)
    paz_id = extract_leading_int(sel)
    if paz_id is None:
        st.warning("Seleziona un paziente valido.")
        return
    with st.form("nuova_anamnesi"):
        st.subheader("Nuova anamnesi")

        data_str = st.text_input("Data (gg/mm/aaaa)", datetime.today().strftime("%d/%m/%Y"))
        motivo = st.text_area("Motivo dell'invio / richiesta principale")

        st.markdown("**Area perinatale e sviluppo**")
        grav = st.text_area("Gravidanza e parto")
        svil = st.text_area("Sviluppo psicomotorio (tappe motorie, controllo del capo, seduto, gattonare, cammino)")
        linguaggio = st.text_area("Sviluppo del linguaggio (prime parole, frasi, eventuali difficoltÃ )")

        st.markdown("**Area scolastica / apprendimenti**")
        scuola = st.text_area("Scuola, rendimento, eventuali DSA / difficoltÃ  specifiche")

        st.markdown("**Area emotivo-relazionale / comportamento**")
        relazioni = st.text_area("Relazioni con pari e adulti, comportamento, regolazione emotiva")
        sensoriale = st.text_area("Profilo sensoriale (udito, vista, tatto, gusto, olfatto, vestibolare, propriocezione)")

        st.markdown("**Stile di vita e salute**")
        sonno = st.text_area("Sonno (addormentamento, risvegli, qualitÃ  del sonno)")
        alimentazione = st.text_area("Alimentazione (selettivitÃ , appetito, ritmi)")
        familiarita = st.text_area("FamiliaritÃ  per disturbi neurologici, psichiatrici, dell'apprendimento, visivi, uditiviâ¦")
        patologie = st.text_area("Patologie pregresse / interventi / ricoveri")
        terapie = st.text_area("Terapie pregresse e in corso (logopedia, TNPEE, psicoterapia, optometria, ecc.)")
        farmaci = st.text_area("Farmaci in uso")
        allergie = st.text_area("Allergie")

        storia_libera = st.text_area("Storia libera / osservazioni genitori (narrazione aperta)")
        note = st.text_area("Note cliniche aggiuntive (per uso interno)")

        salva = st.form_submit_button("Salva anamnesi")

    if salva:
        data_iso, err = parse_data_it_to_iso(
            data_str,
            campo="Data anamnesi",
            min_year=1900,
            max_year=date.today().year + 1
        )
        if err:
            st.error(err)
            conn.close()
            return

        storia_completa = f"""
Gravidanza e parto:
{grav}

Sviluppo psicomotorio:
{svil}

Linguaggio:
{linguaggio}

Scuola / apprendimenti:
{scuola}

Area emotivo-relazionale / comportamento:
{relazioni}

Profilo sensoriale:
{sensoriale}

Sonno:
{sonno}

Alimentazione:
{alimentazione}

FamiliaritÃ :
{familiarita}

Patologie pregresse:
{patologie}

Terapie pregresse / in corso:
{terapie}

Farmaci:
{farmaci}

Allergie:
{allergie}

Storia libera (narrazione):
{storia_libera}
        """.strip()

        cur.execute(
            """
            INSERT INTO Anamnesi (Paziente_ID, Data_Anamnesi, Motivo, Storia, Note)
            VALUES (?,?,?,?,?)
            """,
            (paz_id, data_iso, motivo, storia_completa, note),
        )
        conn.commit()
        st.success("Anamnesi salvata.")

    st.markdown("---")
    st.subheader("Anamnesi esistenti")

    cur.execute(
        "SELECT * FROM Anamnesi WHERE Paziente_ID = ? ORDER BY Data_Anamnesi DESC, ID DESC",
        (paz_id,),
    )
    rows = cur.fetchall()
    if not rows:
        st.info("Nessuna anamnesi per questo paziente.")
        conn.close()
        return

    labels = [
        f"{row_get(r, "ID")} - {row_get(r, "Data_Anamnesi") or ''} - { (row_get(r, "Motivo")[:40] + '...') if row_get(r, "Motivo") and len(row_get(r, "Motivo"))>40 else (row_get(r, "Motivo") or '') }"
        for r in rows
    ]
    sel_an = st.selectbox("Seleziona un'anamnesi da modificare/cancellare", labels)
    an_id = extract_leading_int(sel_an)
    rec = next(r for r in rows if row_get(r, "ID") == an_id)

    with st.form("modifica_anamnesi"):
        data_m = st.text_input(
            "Data (gg/mm/aaaa)",
            datetime.strptime(row_get(rec, "Data_Anamnesi"), "%Y-%m-%d").strftime("%d/%m/%Y")
            if row_get(rec, "Data_Anamnesi") else "",
        )
        motivo_m = st.text_area("Motivo", row_get(rec, "Motivo") or "")
        storia_m = st.text_area("Storia (testo completo)", row_get(rec, "Storia") or "")
        note_m = st.text_area("Note", row_get(rec, "Note") or "")
        col1, col2 = st.columns(2)
        with col1:
            salva_m = st.form_submit_button("Salva modifiche")
        with col2:
            cancella = st.form_submit_button("Elimina anamnesi")

    if salva_m:
        data_iso_m, err = parse_data_it_to_iso(
            data_m,
            campo="Data anamnesi",
            min_year=1900,
            max_year=date.today().year + 1
        )
        if err:
            st.error(err)
            conn.close()
            return
        cur.execute(
            """
            UPDATE Anamnesi
            SET Data_Anamnesi = ?, Motivo = ?, Storia = ?, Note = ?
            WHERE ID = ?
            """,
            (data_iso_m, motivo_m, storia_m, note_m, an_id),
        )
        conn.commit()
        st.success("Anamnesi aggiornata.")

    if cancella:
        cur.execute("DELETE FROM Anamnesi WHERE ID = ?", (an_id,))
        conn.commit()
        st.success("Anamnesi eliminata.")

    conn.close()

# -----------------------------
# UI: Valutazioni visive / oculistiche
# -----------------------------

def ui_valutazioni_visive():
    st.header("Valutazioni visive / oculistiche")

    conn = get_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)

    # Seleziona paziente
    cur.execute("SELECT ID, Cognome, Nome FROM Pazienti ORDER BY Cognome, Nome")
    pazienti = cur.fetchall()
    if not pazienti:
        st.info("Nessun paziente registrato.")
        conn.close()
        return

    options = [paziente_label(p) for p in pazienti]
    sel = st.selectbox("Seleziona paziente", options)
    paz_id = extract_leading_int(sel)
    if paz_id is None:
        st.warning("Seleziona un paziente valido.")
        return
    # Recupero anagrafica completa del paziente (serve per referti e prescrizioni)
    cur.execute("SELECT * FROM Pazienti WHERE ID = ?", (paz_id,))
    paziente = cur.fetchone()


    with st.form("nuova_val_visiva"):
        st.subheader("Nuova valutazione visiva / oculistica")
        data_str = st.text_input("Data (gg/mm/aaaa)", datetime.today().strftime("%d/%m/%Y"))
        tipo = st.text_input("Tipo visita (es. Valutazione optometrica, controllo, ecc.)")
        professionista = st.text_input("Professionista", "")

        st.markdown("### Anamnesi")
        anamnesi_breve = st.text_area("Anamnesi (per questa visita)", key="vv_anamnesi_new")

        st.markdown("### Anamnesi")

        st.markdown("### AcuitÃ  visiva")

        st.markdown("**AcuitÃ  naturale**")
        col1, col2, col3 = st.columns(3)
        with col1:
            ac_nat_od = av_select("OD (naturale)", "", key="ac_nat_od_new")
        with col2:
            ac_nat_os = av_select("OS (naturale)", "", key="ac_nat_os_new")
        with col3:
            ac_nat_oo = av_select("OO (naturale)", "", key="ac_nat_oo_new")

        st.markdown("**AcuitÃ  corretta**")
        col4, col5, col6 = st.columns(3)
        with col4:
            ac_cor_od = av_select("OD (corretta)", "", key="ac_cor_od_new")
        with col5:
            ac_cor_os = av_select("OS (corretta)", "", key="ac_cor_os_new")
        with col6:
            ac_cor_oo = av_select("OO (corretta)", "", key="ac_cor_oo_new")

        st.markdown("### Refrazione")

        st.markdown("**Refrazione oggettiva (SF / CIL / AX)**")
        col_od1, col_od2, col_od3 = st.columns(3)
        with col_od1:
            sf_ogg_od = st.number_input("OD SF oggettiva (D)", -30.0, 30.0, 0.0, 0.25, key="sf_ogg_od")
        with col_od2:
            cil_ogg_od = st.number_input("OD CIL oggettiva (D)", -10.0, 10.0, 0.0, 0.25, key="cil_ogg_od")
        with col_od3:
            ax_ogg_od = st.number_input("OD AX oggettiva (Â°)", 0, 180, 0, 1, key="ax_ogg_od")

        col_os1, col_os2, col_os3 = st.columns(3)
        with col_os1:
            sf_ogg_os = st.number_input("OS SF oggettiva (D)", -30.0, 30.0, 0.0, 0.25, key="sf_ogg_os")
        with col_os2:
            cil_ogg_os = st.number_input("OS CIL oggettiva (D)", -10.0, 10.0, 0.0, 0.25, key="cil_ogg_os")
        with col_os3:
            ax_ogg_os = st.number_input("OS AX oggettiva (Â°)", 0, 180, 0, 1, key="ax_ogg_os")

        st.markdown("**Refrazione soggettiva (SF / CIL / AX)**")
        col_od4, col_od5, col_od6 = st.columns(3)
        with col_od4:
            sf_sogg_od = st.number_input("OD SF soggettiva (D)", -30.0, 30.0, 0.0, 0.25, key="sf_sogg_od")
        with col_od5:
            cil_sogg_od = st.number_input("OD CIL soggettiva (D)", -10.0, 10.0, 0.0, 0.25, key="cil_sogg_od")
        with col_od6:
            ax_sogg_od = st.number_input("OD AX soggettiva (Â°)", 0, 180, 0, 1, key="ax_sogg_od")

        col_os4, col_os5, col_os6 = st.columns(3)
        with col_os4:
            sf_sogg_os = st.number_input("OS SF soggettiva (D)", -30.0, 30.0, 0.0, 0.25, key="sf_sogg_os")
        with col_os5:
            cil_sogg_os = st.number_input("OS CIL soggettiva (D)", -10.0, 10.0, 0.0, 0.25, key="cil_sogg_os")
        with col_os6:
            ax_sogg_os = st.number_input("OS AX soggettiva (Â°)", 0, 180, 0, 1, key="ax_sogg_os")

        st.markdown("### Cheratometria")
        col_kod1, col_kod2, col_kod3, col_kod4 = st.columns(4)
        with col_kod1:
            k1_od_mm = st.number_input("OD K1 (mm)", 6.0, 9.5, 7.80, 0.01, key="k1_od_mm")
        with col_kod2:
            k1_od_D = st.number_input("OD K1 (D)", 35.0, 50.0, 43.00, 0.25, key="k1_od_D")
        with col_kod3:
            k2_od_mm = st.number_input("OD K2 (mm)", 6.0, 9.5, 7.80, 0.01, key="k2_od_mm")
        with col_kod4:
            k2_od_D = st.number_input("OD K2 (D)", 35.0, 50.0, 43.00, 0.25, key="k2_od_D")

        col_kos1, col_kos2, col_kos3, col_kos4 = st.columns(4)
        with col_kos1:
            k1_os_mm = st.number_input("OS K1 (mm)", 6.0, 9.5, 7.80, 0.01, key="k1_os_mm")
        with col_kos2:
            k1_os_D = st.number_input("OS K1 (D)", 35.0, 50.0, 43.00, 0.25, key="k1_os_D")
        with col_kos3:
            k2_os_mm = st.number_input("OS K2 (mm)", 6.0, 9.5, 7.80, 0.01, key="k2_os_mm")
        with col_kos4:
            k2_os_D = st.number_input("OS K2 (D)", 35.0, 50.0, 43.00, 0.25, key="k2_os_D")

        st.markdown("### Tonometria / Pressione oculare")
        col_t1, col_t2 = st.columns(2)
        with col_t1:
            tono_od = st.number_input("Tonometria OD (mmHg)", 0.0, 60.0, 15.0, 0.5, key="tono_od")
        with col_t2:
            tono_os = st.number_input("Tonometria OS (mmHg)", 0.0, 60.0, 15.0, 0.5, key="tono_os")

        st.markdown("### MotilitÃ , cover test, stereopsi, PPC")
        motilita = st.text_input("MotilitÃ  oculare", "")
        cover_test = st.text_input("Cover test (lontano/vicino, OD/OS)", "")
        stereopsi = st.text_input("Stereopsi (secondi d'arco / test)", "")
        ppc_cm = st.number_input("PPC (punto prossimo di convergenza, cm)", 0.0, 50.0, 10.0, 0.5, key="ppc_cm")

        st.markdown("### Colori, pachimetria, esami di struttura/funzione")
        ishihara = st.text_input("Tavole di Ishihara (esito)", "")
        col_p1, col_p2 = st.columns(2)
        with col_p1:
            pachim_od = st.number_input("Pachimetria OD (Âµm)", 400.0, 700.0, 540.0, 1.0, key="pachim_od")
        with col_p2:
            pachim_os = st.number_input("Pachimetria OS (Âµm)", 400.0, 700.0, 540.0, 1.0, key="pachim_os")

        fondo = st.text_area("Fondo oculare (descrizione)", "")
        campo_visivo = st.text_area("Campo visivo (descrizione / esito)", "")
        oct = st.text_area("OCT (descrizione)", "")
        topo = st.text_area("Topografia corneale (descrizione)", "")

        col7, col8 = st.columns(2)
        with col7:
            costo = st.number_input("Costo visita", min_value=0.0, step=5.0, value=0.0)
        with col8:
            pagato = st.checkbox("Pagato", value=False)

        stato_val = st.selectbox("Stato valutazione", ["BOZZA", "DEFINITIVO"], index=0)

        # (A) Anamnesi viene raccolta prima dell'esame (vedi sopra)

        esame_extra = st.text_area("Esame / Refertazione (aggiunte libere, opzionale)")
        conclusioni = st.text_area("Conclusioni / Indicazioni (per il referto)")
        note_libere = st.text_area("Note interne (NON stampate nel referto)")

        salva = st.form_submit_button("Salva valutazione visiva")

    if salva:
        data_iso, err = parse_data_it_to_iso(
            data_str,
            campo="Data valutazione",
            min_year=1900,
            max_year=date.today().year + 1
        )
        if err:
            st.error(err)
            conn.close()
            return

        # Prepariamo un blocco strutturato con tutti i dati oculistici
        dettaglio = f"""
ACUITÃ VISIVA
- NAT: OD {ac_nat_od} | OS {ac_nat_os} | OO {ac_nat_oo}
- CORR: OD {ac_cor_od} | OS {ac_cor_os} | OO {ac_cor_oo}

REFRAZIONE OGGETTIVA (SF / CIL x AX)
- OD: {sf_ogg_od:+.2f} ({cil_ogg_od:+.2f} x {ax_ogg_od}Â°)
- OS: {sf_ogg_os:+.2f} ({cil_ogg_os:+.2f} x {ax_ogg_os}Â°)

REFRAZIONE SOGGETTIVA (SF / CIL x AX)
- OD: {sf_sogg_od:+.2f} ({cil_sogg_od:+.2f} x {ax_sogg_od}Â°)
- OS: {sf_sogg_os:+.2f} ({cil_sogg_os:+.2f} x {ax_sogg_os}Â°)

CHERATOMETRIA
- OD: K1 {k1_od_mm:.2f} mm / {k1_od_D:.2f} D; K2 {k2_od_mm:.2f} mm / {k2_od_D:.2f} D
- OS: K1 {k1_os_mm:.2f} mm / {k1_os_D:.2f} D; K2 {k2_os_mm:.2f} mm / {k2_os_D:.2f} D

TONOMETRIA
- OD: {tono_od:.1f} mmHg
- OS: {tono_os:.1f} mmHg

MOTILITÃ / ALLINEAMENTO
- MotilitÃ  oculare: {motilita}
- Cover test: {cover_test}
- Stereopsi: {stereopsi}
- PPC: {ppc_cm:.1f} cm

COLORI / PACHIMETRIA
- Ishihara: {ishihara}
- Pachimetria OD: {pachim_od:.0f} Âµm
- Pachimetria OS: {pachim_os:.0f} Âµm

ESAMI STRUTTURALI / FUNZIONALI
- Fondo oculare: {fondo}
- Campo visivo: {campo_visivo}
- OCT: {oct}
- Topografia corneale: {topo}
        """.strip()

        esame_txt = dettaglio
        if (esame_extra or "").strip():
            esame_txt = esame_txt + "\n\nAGGIUNTE ESAME:\n" + (esame_extra or "").strip()

        note_finali = (note_libere or "").strip()  # note interne

        cur.execute(
            """
            INSERT INTO Valutazioni_Visive
            (Paziente_ID, Data_Valutazione, Tipo_Visita, Professionista,
             Acuita_Nat_OD, Acuita_Nat_OS, Acuita_Nat_OO,
             Acuita_Corr_OD, Acuita_Corr_OS, Acuita_Corr_OO,
             Costo, Pagato, Stato_Valutazione, Creato_Il, Aggiornato_Il,
             Anamnesi, Esame, Conclusioni, Note)
            VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
            """,
            (
                paz_id,
                data_iso,
                tipo,
                professionista,
                ac_nat_od,
                ac_nat_os,
                ac_nat_oo,
                ac_cor_od,
                ac_cor_os,
                ac_cor_oo,
                float(costo),
                1 if pagato else 0,
                anamnesi_breve,
                esame_txt,
                (conclusioni or "").strip(),
                note_finali,
            ),
        )
        conn.commit()
        st.success("Valutazione visiva salvata.")

    
    # -------- Referti e stampa --------
    with st.expander("Referti e stampa"):
        if not REPORTLAB_AVAILABLE:
            st.error("ReportLab non Ã¨ disponibile: installa 'reportlab' per generare i PDF.")
        else:
            # Elenco valutazioni del paziente
            cur.execute(
                "SELECT * FROM Valutazioni_Visive WHERE Paziente_ID = ? ORDER BY Data_Valutazione DESC, ID DESC",
                (paz_id,),
            )
            vals = cur.fetchall()

            if not vals:
                st.info("Nessuna valutazione salvata per questo paziente.")
            else:
                labels = []
                for v in vals:
                    data_lbl = _format_data_it_from_iso(row_get(v, "Data_Valutazione")) if row_get(v, "Data_Valutazione") else ""
                    tipo_lbl = (row_get(v, "Tipo_Visita") or "").strip()
                    prof_lbl = (row_get(v, "Professionista") or "").strip()
                    parts = []
                    if data_lbl:
                        parts.append(data_lbl)
                    if tipo_lbl:
                        parts.append(tipo_lbl)
                    if prof_lbl:
                        parts.append(prof_lbl)
                    label = " | ".join(parts) if parts else f"Valutazione ID {row_get(v, "ID")}"
                    label = f"{row_get(v, "ID")} - {label}"
                    labels.append(label)

                sel_val = st.selectbox(
                    "Seleziona una valutazione per generare il referto A4",
                    labels,
                    key=f"referto_a4_sel_{paz_id}",
                )
                val_id = extract_leading_int(sel_val)
                valutazione = next(v for v in vals if row_get(v, "ID") == val_id)

                st.caption(f"Stato: **{(row_get(valutazione, "Stato_Valutazione") or 'BOZZA')}**")

                col_dup1, col_dup2 = st.columns([1,3])
                with col_dup1:
                    duplica = st.button("Duplica", key=f"dup_val_{val_id}")
                with col_dup2:
                    st.caption("Crea una nuova valutazione copiando tutti i dati (nuova data = oggi, pagato = NO, stato = BOZZA).")

                if duplica:
                    oggi_iso = date.today().isoformat()
                    cur.execute(
                        """
                        INSERT INTO Valutazioni_Visive
                        (Paziente_ID, Data_Valutazione, Tipo_Visita, Professionista,
                         Stato_Valutazione, Creato_Il, Aggiornato_Il,
                         Acuita_Nat_OD, Acuita_Nat_OS, Acuita_Nat_OO,
                         Acuita_Corr_OD, Acuita_Corr_OS, Acuita_Corr_OO,
                         Costo, Pagato, Anamnesi, Esame, Conclusioni, Note)
                        VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)
                        """,
                        (
                            paz_id,
                            oggi_iso,
                            row_get(valutazione, "Tipo_Visita"),
                            row_get(valutazione, "Professionista"),
                            "BOZZA",
                            now_iso_seconds(),
                            now_iso_seconds(),
                            row_get(valutazione, "Acuita_Nat_OD"),
                            row_get(valutazione, "Acuita_Nat_OS"),
                            row_get(valutazione, "Acuita_Nat_OO"),
                            row_get(valutazione, "Acuita_Corr_OD"),
                            row_get(valutazione, "Acuita_Corr_OS"),
                            row_get(valutazione, "Acuita_Corr_OO"),
                            float(row_get(valutazione, "Costo") or 0.0),
                            0,
                            row_get(valutazione, "Anamnesi"),
                            row_get(valutazione, "Esame"),
                            row_get(valutazione, "Conclusioni"),
                            row_get(valutazione, "Note"),
                        ),
                    )
                    conn.commit()
                    st.success("Valutazione duplicata.")
                    st.rerun()


                modalita_referto = st.radio(
                    "ModalitÃ  referto A4",
                    ["A) Carta intestata (solo contenuto)", "B) PDF con grafica (con Dott. Cirillo)", "C) PDF con grafica (solo The Organism)"],
                    index=0,
                    key=f"referto_a4_mode_{paz_id}",
                )

                if modalita_referto.startswith("A)"):
                    mode = "LETTERHEAD"
                elif modalita_referto.startswith("B)"):
                    mode = "GRAPHIC_CIRILLO"
                else:
                    mode = "GRAPHIC_ORG"

                # Generiamo il PDF "on the fly": download_button lo renderizza senza dover cliccare prima
                try:
                    pdf_bytes = genera_referto_oculistico_pdf_template(
                        paziente=paziente,
                        valutazione=valutazione,
                        mode=mode,
                    )
                    nome_paz_file = f"{(row_get(paziente, "Cognome") or '').strip()}_{(row_get(paziente, "Nome") or '').strip()}".strip("_") or f"paziente_{paz_id}"
                    st.download_button(
                        "Scarica referto A4 (PDF)",
                        data=pdf_bytes,
                        file_name=f"referto_a4_{nome_paz_file}_{val_id}.pdf",
                        mime="application/pdf",
                        key=f"referto_a4_dl_{paz_id}_{val_id}",
                    )
                except Exception as e:
                    st.error(f"Errore nella generazione del PDF: {e}")

# -------- Strumenti optometrici/oculistici stand-alone --------
    st.markdown("---")
    st.subheader("Strumenti di supporto optometrici / oculistici")

    # Cheratometria
    with st.expander("Cheratometria rapida (mm â diottrie)"):
        modo = st.radio("Tipo di conversione", ["mm â diottrie", "diottrie â mm"], key="cherato_modo")
        if modo == "mm â diottrie":
            raggio = st.number_input("Raggio corneale (mm)", min_value=6.0, max_value=9.5, value=7.80, step=0.01, key="cherato_r_mm")
            if st.button("Calcola potere (D)", key="btn_cherato_mmD"):
                D = cherato_mm_to_D(raggio)
                st.success(f"Potere corneale â {D:.2f} D")
        else:
            D_val = st.number_input("Potere corneale (D)", min_value=35.0, max_value=50.0, value=43.00, step=0.25, key="cherato_D")
            if st.button("Calcola raggio (mm)", key="btn_cherato_Dmm"):
                r = cherato_D_to_mm(D_val)
                st.success(f"Raggio corneale â {r:.2f} mm")

    # Conversione occhiali â CL
    with st.expander("Conversione occhiali â lenti a contatto (sfera + cilindro)"):
        st.write("Conversione approssimata, da verificare sempre con la prova in studio.")
        vertex = st.number_input("Distanza vertebrale occhiali (mm)", min_value=8.0, max_value=16.0, value=12.0, step=0.5, key="cl_vertex")

        st.markdown("**Occhio destro (OD)**")
        col_od1, col_od2, col_od3 = st.columns(3)
        with col_od1:
            sph_od = st.number_input("Sfera occhiali OD (D)", min_value=-30.0, max_value=30.0, value=0.0, step=0.25, key="sph_od")
        with col_od2:
            cyl_od = st.number_input("Cilindro occhiali OD (D)", min_value=-10.0, max_value=10.0, value=0.0, step=0.25, key="cyl_od")
        with col_od3:
            ax_od = st.number_input("Asse occhiali OD (Â°)", min_value=0, max_value=180, value=0, step=1, key="ax_od")

        st.markdown("**Occhio sinistro (OS)**")
        col_os1, col_os2, col_os3 = st.columns(3)
        with col_os1:
            sph_os = st.number_input("Sfera occhiali OS (D)", min_value=-30.0, max_value=30.0, value=0.0, step=0.25, key="sph_os")
        with col_os2:
            cyl_os = st.number_input("Cilindro occhiali OS (D)", min_value=-10.0, max_value=10.0, value=0.0, step=0.25, key="cyl_os")
        with col_os3:
            ax_os = st.number_input("Asse occhiali OS (Â°)", min_value=0, max_value=180, value=0, step=1, key="ax_os")

        if st.button("Calcola lenti a contatto", key="btn_cl_conv"):
            sph_cl_od, cyl_cl_od, ax_cl_od = convert_occhiali_to_cl(sph_od, cyl_od, ax_od, vertex_mm=vertex)
            sph_cl_os, cyl_cl_os, ax_cl_os = convert_occhiali_to_cl(sph_os, cyl_os, ax_os, vertex_mm=vertex)

            st.success(
                f"**OD (CL):** {sph_cl_od:+.2f} D  {cyl_cl_od:+.2f} D x {ax_cl_od:.0f}Â°"
            )
            st.success(
                f"**OS (CL):** {sph_cl_os:+.2f} D  {cyl_cl_os:+.2f} D x {ax_cl_os:.0f}Â°"
            )
            st.info("Puoi arrotondare ulteriormente secondo le disponibilitÃ  reali delle lenti a contatto.")

    # -------- Valutazioni esistenti --------
    st.markdown("---")
    st.subheader("Valutazioni esistenti")

    cur.execute(
        "SELECT * FROM Valutazioni_Visive WHERE Paziente_ID = ? ORDER BY Data_Valutazione DESC, ID DESC",
        (paz_id,),
    )
    rows = cur.fetchall()
    if not rows:
        st.info("Nessuna valutazione per questo paziente.")
        conn.close()
        return

    labels = [
        f"{row_get(r, "ID")} - {row_get(r, "Data_Valutazione") or ''} - { (row_get(r, "Tipo_Visita")[:40] + '...') if row_get(r, "Tipo_Visita") and len(row_get(r, "Tipo_Visita"))>40 else (row_get(r, "Tipo_Visita") or '') }"
        for r in rows
    ]
    sel_v = st.selectbox("Seleziona una valutazione da modificare/cancellare", labels)
    val_id = extract_leading_int(sel_v)
    rec = next(r for r in rows if row_get(r, "ID") == val_id)
    st.markdown("#### Referto oculistico in PDF (A4)")

    if not REPORTLAB_AVAILABLE:
        st.info("Per generare il referto in PDF installa il pacchetto 'reportlab' (es. `pip install reportlab`).")
    else:
        pdf_bytes_int = genera_referto_oculistico_pdf(paziente, rec, include_header=True)
        pdf_bytes_no = genera_referto_oculistico_pdf(paziente, rec, include_header=False)
        base_name = f"{row_get(paziente, "Cognome")}_{row_get(paziente, "Nome")}_{val_id}"

        colr1, colr2 = st.columns(2)
        with colr1:
            st.download_button(
                "Scarica referto A4 (con intestazione)",
                data=pdf_bytes_int,
                file_name=f"referto_{base_name}_intestazione.pdf",
                mime="application/pdf",
                key=f"dl_ref_int_{val_id}",
            )
        with colr2:
            st.download_button(
                "Scarica referto A4 (senza intestazione)",
                data=pdf_bytes_no,
                file_name=f"referto_{base_name}_senza_intestazione.pdf",
                mime="application/pdf",
                key=f"dl_ref_no_{val_id}",
            )

    with st.form("modifica_val_visiva"):
        data_m = st.text_input(
            "Data (gg/mm/aaaa)",
            datetime.strptime(row_get(rec, "Data_Valutazione"), "%Y-%m-%d").strftime("%d/%m/%Y")
            if row_get(rec, "Data_Valutazione") else "",
        )
        tipo_m = st.text_input("Tipo visita", row_get(rec, "Tipo_Visita") or "")
        professionista_m = st.text_input("Professionista", row_get(rec, "Professionista") or "")

        stato_m = st.selectbox("Stato valutazione", ["BOZZA","DEFINITIVO"], index=(0 if (row_get(rec, "Stato_Valutazione") or "BOZZA")=="BOZZA" else 1))

        st.markdown("### Anamnesi")
        anamnesi_m = st.text_area("Anamnesi (per questa visita)", row_get(rec, "Anamnesi") or "", key="vv_anamnesi_edit")

        st.markdown("### Esame / Refertazione")
        esame_m = st.text_area("Esame / Refertazione", row_get(rec, "Esame") or "", key="vv_esame_edit")

        st.markdown("### Conclusioni / Indicazioni")
        conclusioni_m = st.text_area("Conclusioni / Indicazioni", row_get(rec, "Conclusioni") or "", key="vv_concl_edit")


        st.markdown("**AcuitÃ  naturale**")
        col1, col2, col3 = st.columns(3)
        with col1:
            ac_nat_od_m = av_select("OD (naturale)", row_get(rec, "Acuita_Nat_OD"), key="ac_nat_od_m")
        with col2:
            ac_nat_os_m = av_select("OS (naturale)", row_get(rec, "Acuita_Nat_OS"), key="ac_nat_os_m")
        with col3:
            ac_nat_oo_m = av_select("OO (naturale)", row_get(rec, "Acuita_Nat_OO"), key="ac_nat_oo_m")

        st.markdown("**AcuitÃ  corretta**")
        col4, col5, col6 = st.columns(3)
        with col4:
            ac_cor_od_m = av_select("OD (corretta)", row_get(rec, "Acuita_Corr_OD"), key="ac_cor_od_m")
        with col5:
            ac_cor_os_m = av_select("OS (corretta)", row_get(rec, "Acuita_Corr_OS"), key="ac_cor_os_m")
        with col6:
            ac_cor_oo_m = av_select("OO (corretta)", row_get(rec, "Acuita_Corr_OO"), key="ac_cor_oo_m")

        costo_m = st.number_input(
            "Costo visita",
            min_value=0.0,
            step=5.0,
            value=float(row_get(rec, "Costo") or 0.0),
            key="costo_m",
        )
        pagato_m = st.checkbox("Pagato", value=bool(row_get(rec, "Pagato")), key="pagato_m")

        anamnesi_m = st.text_area("Anamnesi (per questa visita)", row_get(rec, "Anamnesi", "") or "", key="vv_anamnesi_edit2")

        esame_m = st.text_area("Esame / Refertazione (per il referto)", row_get(rec, "Esame", "") or "", key="vv_esame_edit2")
        conclusioni_m = st.text_area("Conclusioni / Indicazioni (per il referto)", row_get(rec, "Conclusioni", "") or "", key="vv_concl_edit2")
        note_m = st.text_area("Note interne (NON stampate nel referto)", row_get(rec, "Note", "") or "", key="vv_note_edit2")

        col9, col10 = st.columns(2)
        with col9:
            salva_m = st.form_submit_button("Salva modifiche")
        with col10:
            cancella = st.form_submit_button("Elimina valutazione")

    if salva_m:
        data_iso_m, err = parse_data_it_to_iso(
            data_m,
            campo="Data seduta",
            min_year=1900,
            max_year=date.today().year + 1
        )
        if err:
            st.error(err)
            conn.close()
            return
        cur.execute(
            """
            UPDATE Valutazioni_Visive
            SET Data_Valutazione = ?, Tipo_Visita = ?, Professionista = ?,
                Stato_Valutazione = ?, Aggiornato_Il = ?,
                Acuita_Nat_OD = ?, Acuita_Nat_OS = ?, Acuita_Nat_OO = ?,
                Acuita_Corr_OD = ?, Acuita_Corr_OS = ?, Acuita_Corr_OO = ?,
                Costo = ?, Pagato = ?,
                Anamnesi = ?, Esame = ?, Conclusioni = ?, Note = ?
            WHERE ID = ?
            """,
            (
                data_iso_m,
                tipo_m,
                professionista_m,
                stato_m,
                now_iso_seconds(),
                ac_nat_od_m,
                ac_nat_os_m,
                ac_nat_oo_m,
                ac_cor_od_m,
                ac_cor_os_m,
                ac_cor_oo_m,
                float(costo_m),
                1 if pagato_m else 0,
                anamnesi_m,
                note_m,
                val_id,
            ),
        )
        conn.commit()
        st.success("Valutazione aggiornata.")

    if cancella:
        cur.execute("DELETE FROM Valutazioni_Visive WHERE ID = ?", (val_id,))
        conn.commit()
        st.success("Valutazione eliminata.")
    st.markdown("---")
    st.subheader("Prescrizione occhiali (formato A5)")

    if not REPORTLAB_AVAILABLE:
        st.info("Per generare la prescrizione in PDF installa il pacchetto 'reportlab' (es. `pip install reportlab`).")
    else:
        st.write("Compila la prescrizione finale e scarica un PDF A5 pronto per la stampa.")

        modalita_prescr = st.radio(
            "ModalitÃ  prescrizione A5",
            ["Con Dott. Cirillo (grafica completa)", "Solo The Organism (senza Dottore)"],
            index=0,
            key=f"prescr_a5_mode_{paz_id}",
        )
        template_mode = "CIRILLO" if modalita_prescr.startswith("Con") else "ORG_ONLY"

        with st.form("prescrizione_a5_form"):
            data_prescr_str = st.text_input(
                "Data prescrizione (gg/mm/aaaa)",
                datetime.today().strftime("%d/%m/%Y"),
                key="data_prescr_a5",
            )

            st.markdown("**LONTANO**")
            colL1, colL2 = st.columns(2)
            with colL1:
                sf_lon_od = st.number_input("OD SF lontano (D)", -30.0, 30.0, 0.0, 0.25, key="sf_lon_od_a5")
                cil_lon_od = st.number_input("OD CIL lontano (D)", -10.0, 10.0, 0.0, 0.25, key="cil_lon_od_a5")
                ax_lon_od = st.number_input("OD AX lontano (Â°)", 0, 180, 0, 1, key="ax_lon_od_a5")
            with colL2:
                sf_lon_os = st.number_input("OS SF lontano (D)", -30.0, 30.0, 0.0, 0.25, key="sf_lon_os_a5")
                cil_lon_os = st.number_input("OS CIL lontano (D)", -10.0, 10.0, 0.0, 0.25, key="cil_lon_os_a5")
                ax_lon_os = st.number_input("OS AX lontano (Â°)", 0, 180, 0, 1, key="ax_lon_os_a5")

            st.markdown("**INTERMEDIO**")
            colI1, colI2 = st.columns(2)
            with colI1:
                sf_int_od = st.number_input("OD SF intermedio (D)", -30.0, 30.0, 0.0, 0.25, key="sf_int_od_a5")
                cil_int_od = st.number_input("OD CIL intermedio (D)", -10.0, 10.0, 0.0, 0.25, key="cil_int_od_a5")
                ax_int_od = st.number_input("OD AX intermedio (Â°)", 0, 180, 0, 1, key="ax_int_od_a5")
            with colI2:
                sf_int_os = st.number_input("OS SF intermedio (D)", -30.0, 30.0, 0.0, 0.25, key="sf_int_os_a5")
                cil_int_os = st.number_input("OS CIL intermedio (D)", -10.0, 10.0, 0.0, 0.25, key="cil_int_os_a5")
                ax_int_os = st.number_input("OS AX intermedio (Â°)", 0, 180, 0, 1, key="ax_int_os_a5")

            st.markdown("**VICINO**")
            colV1, colV2 = st.columns(2)
            with colV1:
                sf_vic_od = st.number_input("OD SF vicino (D)", -30.0, 30.0, 0.0, 0.25, key="sf_vic_od_a5")
                cil_vic_od = st.number_input("OD CIL vicino (D)", -10.0, 10.0, 0.0, 0.25, key="cil_vic_od_a5")
                ax_vic_od = st.number_input("OD AX vicino (Â°)", 0, 180, 0, 1, key="ax_vic_od_a5")
            with colV2:
                sf_vic_os = st.number_input("OS SF vicino (D)", -30.0, 30.0, 0.0, 0.25, key="sf_vic_os_a5")
                cil_vic_os = st.number_input("OS CIL vicino (D)", -10.0, 10.0, 0.0, 0.25, key="cil_vic_os_a5")
                ax_vic_os = st.number_input("OS AX vicino (Â°)", 0, 180, 0, 1, key="ax_vic_os_a5")

            lenti_possibili = [
                "Progressive",
                "Per vicino/intermedio",
                "Fotocromatiche",
                "Polarizzate",
                "Controllo miopia",
                "Trattamento antiriflesso",
            ]
            lenti_scelte = st.multiselect(
                "Lenti consigliate",
                options=lenti_possibili,
                key="lenti_scelte_a5",
            )

            altri_trattamenti = st.text_input(
                "Altri trattamenti (facoltativo)",
                key="altro_tratt_a5",
            )

            note_prescrizione = st.text_area(
                "Note aggiuntive per la prescrizione",
                key="note_prescr_a5",
            )

            genera_pdf = st.form_submit_button("Genera PDF A5")

        if genera_pdf:
            data_iso_prescr = None
            data_iso_prescr, err = parse_data_it_to_iso(
                data_prescr_str,
                campo="Data prescrizione",
                min_year=1900,
                max_year=date.today().year + 1
            )
            if err:
                st.error(err)
                data_iso_prescr = None

            pdf_bytes = genera_prescrizione_occhiali_a5_pdf(
                paziente=paziente,
                data_prescrizione_iso=data_iso_prescr,
                template_mode=template_mode,
                sf_lon_od=sf_lon_od, cil_lon_od=cil_lon_od, ax_lon_od=ax_lon_od,
                sf_lon_os=sf_lon_os, cil_lon_os=cil_lon_os, ax_lon_os=ax_lon_os,
                sf_int_od=sf_int_od, cil_int_od=cil_int_od, ax_int_od=ax_int_od,
                sf_int_os=sf_int_os, cil_int_os=cil_int_os, ax_int_os=ax_int_os,
                sf_vic_od=sf_vic_od, cil_vic_od=cil_vic_od, ax_vic_od=ax_vic_od,
                sf_vic_os=sf_vic_os, cil_vic_os=cil_vic_os, ax_vic_os=ax_vic_os,
                lenti_scelte=lenti_scelte,
                altri_trattamenti=altri_trattamenti,
                note=note_prescrizione,
            )

            filename = f"prescrizione_occhiali_{row_get(paziente, "Cognome")}_{row_get(paziente, "Nome")}.pdf"
            st.download_button(
                "Scarica prescrizione occhiali (A5)",
                data=pdf_bytes,
                file_name=filename,
                mime="application/pdf",
                key="dl_prescr_a5",
            )
    st.markdown("---")
    st.subheader("Referto oculistico / optometrico (PDF A4)")

    if not REPORTLAB_AVAILABLE:
        st.info(
            "Per generare il referto in PDF Ã¨ necessario avere installato il pacchetto "
            "`reportlab`.\n"
            "Da terminale: `pip install reportlab`."
        )
    else:
        col_r1, col_r2 = st.columns([2, 1])
        with col_r1:
            with_header = st.checkbox(
                "Stampa con intestazione dello studio (usa carta bianca)",
                value=False,
                key=f"hdr_referto_{val_id}",
            )

        if st.button("Genera referto A4 per questa valutazione", key=f"btn_referto_{val_id}"):
            # Ricarico i dati aggiornati dal DB
            cur.execute("SELECT * FROM Pazienti WHERE ID = ?", (paz_id,))
            paziente = cur.fetchone()
            cur.execute("SELECT * FROM Valutazioni_Visive WHERE ID = ?", (val_id,))
            valutazione = cur.fetchone()

            if not paziente or not valutazione:
                st.error("Errore nel recupero dei dati dal database.")
            else:
                pdf_bytes = genera_referto_oculistico_a4_pdf(
                    paziente=paziente,
                    valutazione=valutazione,
                    with_header=with_header,
                )
                st.download_button(
                    "Scarica referto A4 (PDF)",
                    data=pdf_bytes,
                    file_name=f"referto_visivo_{row_get(paziente, "Cognome")}_{row_get(paziente, "Nome")}.pdf",
                    mime="application/pdf",
                    key=f"download_referto_{val_id}",
                )

    conn.close()

# -----------------------------
# UI: Sedute / Terapie
# -----------------------------

def ui_sedute():
    st.header("Sedute / Terapie")

    conn = get_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)

    cur.execute("SELECT ID, Cognome, Nome FROM Pazienti ORDER BY Cognome, Nome")
    pazienti = cur.fetchall()
    if not pazienti:
        st.info("Nessun paziente registrato.")
        conn.close()
        return

    options = [paziente_label(p) for p in pazienti]
    sel = st.selectbox("Seleziona paziente", options)
    paz_id = extract_leading_int(sel)
    if paz_id is None:
        st.warning("Seleziona un paziente valido.")
        return
    with st.form("nuova_seduta"):
        st.subheader("Nuova seduta")
        data_str = st.text_input("Data (gg/mm/aaaa)", datetime.today().strftime("%d/%m/%Y"))
        terapia = st.text_input("Tipo di terapia (es. logopedia, neuropsicomotricitÃ , optometria...)", "")
        professionista = st.text_input("Professionista", "")
        col1, col2 = st.columns(2)
        with col1:
            costo = st.number_input("Costo seduta", min_value=0.0, step=5.0, value=0.0)
        with col2:
            pagato = st.checkbox("Pagato", value=False)
        note = st.text_area("Note")
        salva = st.form_submit_button("Salva seduta")

    if salva:
        data_iso, err = parse_data_it_to_iso(
            data_str,
            campo="Data seduta",
            min_year=1900,
            max_year=date.today().year + 1
        )
        if err:
            st.error(err)
            conn.close()
            return
        cur.execute(
            """
            INSERT INTO Sedute
            (Paziente_ID, Data_Seduta, Terapia, Professionista, Costo, Pagato, Note)
            VALUES (?,?,?,?,?,?,?)
            """,
            (
                paz_id,
                data_iso,
                terapia,
                professionista,
                float(costo),
                1 if pagato else 0,
                note,
            ),
        )
        conn.commit()
        st.success("Seduta salvata.")

    st.markdown("---")
    st.subheader("Sedute esistenti")

    cur.execute(
        "SELECT * FROM Sedute WHERE Paziente_ID = ? ORDER BY Data_Seduta DESC, ID DESC",
        (paz_id,),
    )
    rows = cur.fetchall()
    if not rows:
        st.info("Nessuna seduta per questo paziente.")
        conn.close()
        return

    labels = [
        f"{row_get(r, "ID")} - {row_get(r, "Data_Seduta") or ''} - { (row_get(r, "Terapia")[:40] + '...') if row_get(r, "Terapia") and len(row_get(r, "Terapia"))>40 else (row_get(r, "Terapia") or '') }"
        for r in rows
    ]
    sel_s = st.selectbox("Seleziona una seduta da modificare/cancellare", labels)
    sed_id = extract_leading_int(sel_s)
    rec = next(r for r in rows if row_get(r, "ID") == sed_id)

    with st.form("modifica_seduta"):
        data_m = st.text_input(
            "Data (gg/mm/aaaa)",
            datetime.strptime(row_get(rec, "Data_Seduta"), "%Y-%m-%d").strftime("%d/%m/%Y")
            if row_get(rec, "Data_Seduta") else "",
        )
        terapia_m = st.text_input("Terapia", row_get(rec, "Terapia") or "")
        professionista_m = st.text_input("Professionista", row_get(rec, "Professionista") or "")
        col1, col2 = st.columns(2)
        with col1:
            costo_m = st.number_input(
                "Costo seduta",
                min_value=0.0,
                step=5.0,
                value=float(row_get(rec, "Costo") or 0.0),
                key="costo_sed_m",
            )
        with col2:
            pagato_m = st.checkbox("Pagato", value=bool(row_get(rec, "Pagato")), key="pagato_sed_m")
        note_m = st.text_area("Note", row_get(rec, "Note") or "")

        col3, col4 = st.columns(2)
        with col3:
            salva_m = st.form_submit_button("Salva modifiche")
        with col4:
            cancella = st.form_submit_button("Elimina seduta")

    if salva_m:
        data_iso_m, err = parse_data_it_to_iso(
            data_m,
            campo="Data seduta",
            min_year=1900,
            max_year=date.today().year + 1
        )
        if err:
            st.error(err)
            conn.close()
            return
        cur.execute(
            """
            UPDATE Sedute
            SET Data_Seduta = ?, Terapia = ?, Professionista = ?, Costo = ?, Pagato = ?, Anamnesi = ?, Note = ?
            WHERE ID = ?
            """,
            (
                data_iso_m,
                terapia_m,
                professionista_m,
                float(costo_m),
                1 if pagato_m else 0,
                anamnesi_m,
                note_m,
                sed_id,
            ),
        )
        conn.commit()
        st.success("Seduta aggiornata.")

    if cancella:
        cur.execute("DELETE FROM Sedute WHERE ID = ?", (sed_id,))
        conn.commit()
        st.success("Seduta eliminata.")

    conn.close()
def ui_coupons():
    st.header("Gestione coupon OF / SDS")

    conn = get_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)

    # Elenco pazienti
    cur.execute("SELECT ID, Cognome, Nome FROM Pazienti ORDER BY Cognome, Nome")
    pazienti = cur.fetchall()
    if not pazienti:
        st.info("Nessun paziente registrato.")
        conn.close()
        return

    opt_paz = [paziente_label(p) for p in pazienti]
    sel = st.selectbox("Seleziona paziente", opt_paz)
    paz_id = extract_leading_int(sel)
    if paz_id is None:
        st.warning("Seleziona un paziente valido.")
        return
    st.markdown("### Aggiungi nuovo coupon")

    with st.form("form_nuovo_coupon"):
        col1, col2 = st.columns(2)
        with col1:
            tipo_coupon = st.selectbox("Tipo coupon", ["OF", "SDS"], key="tipo_coupon_new")
        with col2:
            codice_coupon = st.text_input("Codice / numero coupon", key="codice_coupon_new")

        col3, col4 = st.columns(2)
        with col3:
            data_c_str = st.text_input(
                "Data assegnazione (gg/mm/aaaa)",
                datetime.today().strftime("%d/%m/%Y"),
                key="data_coupon_new",
            )
        with col4:
            usato_flag = st.checkbox("GiÃ  utilizzato", value=False, key="usato_coupon_new")

        note_coupon = st.text_input("Note coupon (facoltative)", key="note_coupon_new")

        salva_c = st.form_submit_button("Aggiungi coupon")

    if salva_c:
        data_c_iso, err = parse_data_it_to_iso(
            data_c_str,
            campo="Data assegnazione coupon",
            min_year=1900,
            max_year=date.today().year + 1
        )
        if err:
            st.error(err)
            conn.close()
            return

        cur.execute(
            """
            INSERT INTO Coupons
            (Paziente_ID, Tipo_Coupon, Codice_Coupon, Data_Assegnazione, Note, Utilizzato)
            VALUES (?,?,?,?,?,?)
            """,
            (
                paz_id,
                tipo_coupon,
                codice_coupon.strip() or None,
                data_c_iso,
                note_coupon.strip() or None,
                1 if usato_flag else 0,
            ),
        )
        conn.commit()
        st.success("Coupon aggiunto correttamente.")
        st.rerun()

    st.markdown("---")
    st.subheader("Coupon del paziente selezionato")

    cur.execute(
        "SELECT * FROM Coupons WHERE Paziente_ID = ? ORDER BY Data_Assegnazione DESC, ID DESC",
        (paz_id,),
    )
    coupons = cur.fetchall()

    if not coupons:
        st.info("Nessun coupon per questo paziente.")
        conn.close()
        return

    for c in coupons:
        data_it = ""
        if row_get(c, "Data_Assegnazione"):
            try:
                data_it = datetime.strptime(row_get(c, "Data_Assegnazione"), "%Y-%m-%d").strftime("%d/%m/%Y")
            except Exception:
                data_it = row_get(c, "Data_Assegnazione")

        stato = "USATO" if row_get(c, "Utilizzato") else "NON USATO"

        col1, col2, col3, col4 = st.columns([4, 2, 2, 2])
        with col1:
            st.write(
                f"**ID {row_get(c, "ID")}** â {row_get(c, "Tipo_Coupon")} â "
                f"{row_get(c, "Codice_Coupon") or '-'} â {data_it or 'data n/d'}"
            )
            if row_get(c, "Note"):
                st.caption(f"Note: {row_get(c, "Note")}")
        with col2:
            st.write(f"Stato: **{stato}**")
        with col3:
            if row_get(c, "Utilizzato"):
                if st.button("Segna NON usato", key=f"c_notused_{row_get(c, "ID")}"):
                    cur.execute(
                        "UPDATE Coupons SET Utilizzato = 0 WHERE ID = ?",
                        (row_get(c, "ID"),),
                    )
                    conn.commit()
                    st.rerun()
            else:
                if st.button("Segna USATO", key=f"c_used_{row_get(c, "ID")}"):
                    cur.execute(
                        "UPDATE Coupons SET Utilizzato = 1 WHERE ID = ?",
                        (row_get(c, "ID"),),
                    )
                    conn.commit()
                    st.rerun()
        with col4:
            if st.button("Elimina", key=f"c_del_{row_get(c, "ID")}"):
                cur.execute("DELETE FROM Coupons WHERE ID = ?", (row_get(c, "ID"),))
                conn.commit()
                st.rerun()

    conn.close()


   
# -----------------------------
# UI: Dashboard incassi
# -----------------------------

def ui_dashboard():
    st.header("Dashboard incassi")

    conn = get_connection()
    cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)

    st.subheader("Filtri")

    oggi = date.today()
    col1, col2, col3 = st.columns(3)
    with col1:
        data_da_str = st.text_input("Dal (gg/mm/aaaa)", oggi.strftime("%d/%m/%Y"))
    with col2:
        data_a_str = st.text_input("Al (gg/mm/aaaa)", oggi.strftime("%d/%m/%Y"))
    with col3:
        professionista_f = st.text_input("Filtra per professionista (facoltativo)", "")

    iso_da, err_da = parse_data_it_to_iso(
        data_da_str,
        campo="Data inizio",
        min_year=1900,
        max_year=date.today().year + 1
    )
    iso_a, err_a = parse_data_it_to_iso(
        data_a_str,
        campo="Data fine",
        min_year=1900,
        max_year=date.today().year + 1
    )
    if err_da or err_a or not iso_da or not iso_a:
        st.error(err_da or err_a or "Formato data non valido. Usa gg/mm/aaaa.")
        conn.close()
        return

    data_da = date.fromisoformat(iso_da)
    data_a = date.fromisoformat(iso_a)

    if data_a < data_da:
        st.error("Intervallo date non valido: la data finale Ã¨ precedente alla data iniziale.")
        conn.close()
        return


    if data_a < data_da:
        st.error("La data finale non puÃ² essere precedente a quella iniziale.")
        conn.close()
        return

    data_da_iso = data_da.isoformat()
    data_a_iso = data_a.isoformat()

    # --- Incassi da Valutazioni Visive ---
    st.markdown("### Incassi da valutazioni visive / oculistiche")

    query_v = """
        SELECT Data_Valutazione AS Data, Professionista, Costo, Pagato
        FROM Valutazioni_Visive
        WHERE Data_Valutazione BETWEEN ? AND ?
    """
    params_v = [data_da_iso, data_a_iso]
    if professionista_f.strip():
        query_v += " AND Professionista LIKE ?"
        params_v.append(f"%{professionista_f.strip()}%")

    cur.execute(query_v, params_v)
    vis = cur.fetchall()

    incasso_vis = sum((row_get(r, "Costo") or 0.0) for r in vis if row_get(r, "Pagato"))
    st.write(f"**Totale incassi visite (periodo): â¬ {incasso_vis:.2f}**")

    # --- Incassi da Sedute ---
    st.markdown("### Incassi da sedute / terapie")

    query_s = """
        SELECT Data_Seduta AS Data, Professionista, Terapia, Costo, Pagato
        FROM Sedute
        WHERE Data_Seduta BETWEEN ? AND ?
    """
    params_s = [data_da_iso, data_a_iso]
    if professionista_f.strip():
        query_s += " AND Professionista LIKE ?"
        params_s.append(f"%{professionista_f.strip()}%")

    cur.execute(query_s, params_s)
    sed = cur.fetchall()

    incasso_sed = sum((row_get(r, "Costo") or 0.0) for r in sed if row_get(r, "Pagato"))
    st.write(f"**Totale incassi sedute (periodo): â¬ {incasso_sed:.2f}**")

    st.markdown("### Totale studio")
    st.success(f"**Totale generale incassato: â¬ {incasso_vis + incasso_sed:.2f}**")

    conn.close()



# -----------------------------
# UI: Integrazioni / Backup
# -----------------------------
def ui_integrazioni():
    st.header("Integrazioni / Backup")

    st.markdown("### Backup del database (consigliato)")
    st.write("Scarica una copia del file SQLite per backup manuale o per trasferire il gestionale su un altro PC.")

    db_path = DB_PATH if 'DB_PATH' in globals() else 'the_organism_gestionale_v2.db'
    if os.path.exists(db_path):
        with open(db_path, "rb") as f:
            st.download_button(
                "Scarica backup database (.db)",
                data=f.read(),
                file_name=os.path.basename(db_path),
                mime="application/octet-stream",
            )
    else:
        st.warning(f"Database non trovato: {db_path}")

    st.markdown("---")
    st.markdown("### Export Excel completo (Pazienti + Storico)")
    st.caption("Esporta piÃ¹ fogli nello stesso file: Pazienti, Anamnesi, Valutazioni, Sedute, Coupons.")

    col1, col2, col3 = st.columns(3)
    with col1:
        include_arch = st.checkbox("Includi ARCHIVIATI", value=False)
    with col2:
        data_da = st.text_input("Dal (gg/mm/aaaa) â filtra Valutazioni/Sedute", "")
    with col3:
        data_a = st.text_input("Al (gg/mm/aaaa) â filtra Valutazioni/Sedute", "")

    prof_filter = st.text_input("Filtro Professionista (opzionale)", "")

    if st.button("Genera Excel completo"):
        conn = get_connection()
        cur = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)

        # parse date filters (non bloccante: se vuote -> nessun filtro)
        data_da_iso = None
        data_a_iso = None
        if data_da.strip():
            d = parse_data_it(data_da.strip(), campo="Dal")
            if not d:
                st.error("Data 'Dal' non valida (usa gg/mm/aaaa).")
                conn.close()
                st.stop()
            data_da_iso = d.isoformat()
        if data_a.strip():
            d = parse_data_it(data_a.strip(), campo="Al")
            if not d:
                st.error("Data 'Al' non valida (usa gg/mm/aaaa).")
                conn.close()
                st.stop()
            data_a_iso = d.isoformat()

        try:
            from openpyxl import Workbook
        except Exception:
            st.error("Per esportare in Excel installa openpyxl: pip install openpyxl")
            conn.close()
            st.stop()

        wb = Workbook()
        wb.remove(wb.active)

        def add_sheet(title: str, query: str, params: list):
            ws = wb.create_sheet(title=title[:31])
            cur.execute(query, params)
            rows = cur.fetchall()
            if not rows:
                ws.append(["(nessun dato)"])
                return
            headers = rows[0].keys()
            ws.append(list(headers))
            for r in rows:
                ws.append([r[h] if h in r.keys() else None for h in headers])

        # Pazienti
        q_p = "SELECT * FROM Pazienti"
        params = []
        if not include_arch:
            q_p += " WHERE Stato_Paziente = 'ATTIVO'"
        q_p += " ORDER BY Cognome, Nome"
        add_sheet("Pazienti", q_p, params)

        # Anamnesi (tutte)
        add_sheet("Anamnesi", "SELECT * FROM Anamnesi ORDER BY Data_Anamnesi DESC, ID DESC", [])

        # Valutazioni (filtrate)
        q_v = "SELECT * FROM Valutazioni_Visive"
        pv = []
        cond = []
        if data_da_iso and data_a_iso:
            cond.append("Data_Valutazione BETWEEN ? AND ?")
            pv += [data_da_iso, data_a_iso]
        elif data_da_iso:
            cond.append("Data_Valutazione >= ?")
            pv += [data_da_iso]
        elif data_a_iso:
            cond.append("Data_Valutazione <= ?")
            pv += [data_a_iso]
        if prof_filter.strip():
            cond.append("Professionista LIKE ?")
            pv += [f"%{prof_filter.strip()}%"]
        if cond:
            q_v += " WHERE " + " AND ".join(cond)
        q_v += " ORDER BY Data_Valutazione DESC, ID DESC"
        add_sheet("Valutazioni", q_v, pv)

        # Sedute (filtrate)
        q_s = "SELECT * FROM Sedute"
        ps = []
        cond = []
        if data_da_iso and data_a_iso:
            cond.append("Data_Seduta BETWEEN ? AND ?")
            ps += [data_da_iso, data_a_iso]
        elif data_da_iso:
            cond.append("Data_Seduta >= ?")
            ps += [data_da_iso]
        elif data_a_iso:
            cond.append("Data_Seduta <= ?")
            ps += [data_a_iso]
        if prof_filter.strip():
            cond.append("Professionista LIKE ?")
            ps += [f"%{prof_filter.strip()}%"]
        if cond:
            q_s += " WHERE " + " AND ".join(cond)
        q_s += " ORDER BY Data_Seduta DESC, ID DESC"
        add_sheet("Sedute", q_s, ps)

        # Coupons
        add_sheet("Coupons", "SELECT * FROM Coupons ORDER BY Data_Assegnazione DESC, ID DESC", [])

        out = io.BytesIO()
        wb.save(out)
        out.seek(0)

        conn.close()

        st.download_button(
            "Scarica Excel completo",
            data=out.getvalue(),
            file_name=f"export_completo_{date.today().isoformat()}.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

    st.markdown("---")
    st.markdown("### Integrazioni (CRM / Email marketing)")
    st.write("Quando vuoi, possiamo aggiungere:")
    st.markdown("""- export CSV compatibile Klaviyo/Mailchimp
- invio automatico dopo consenso marketing
- sincronizzazione su cloud (Drive/Dropbox)""")


# -----------------------------
# Main
# -----------------------------

def main():
    st.set_page_config(
        page_title="The Organism â Gestionale Studio",
        layout="wide"
    )

    # inizializza il database (se le tabelle non ci sono le crea)
    init_db()

    # login obbligatorio
    if not login():
        return

    st.sidebar.markdown(f"ð¤ Utente: **{st.session_state.get('logged_user','')}**")
    _sidebar_db_indicator()

    # menu laterale
    st.sidebar.title("Navigazione")
    sezione = st.sidebar.radio(
        "Vai a",
        [
            "Pazienti",
            "Anamnesi",
            "Valutazioni visive / oculistiche",
            "Sedute / Terapie",
            "Coupon OF / SDS",
            "Dashboard incassi",
            "Integrazioni / Backup",
        ],
    )

    # routing alle varie sezioni
    if sezione == "Pazienti":
        ui_pazienti()
    elif sezione == "Anamnesi":
        ui_anamnesi()
    elif sezione == "Valutazioni visive / oculistiche":
        ui_valutazioni_visive()
    elif sezione == "Sedute / Terapie":
        ui_sedute()
    elif sezione == "Coupon OF / SDS":
        ui_coupons()
    elif sezione == "Dashboard incassi":
        ui_dashboard()
    elif sezione == "Integrazioni / Backup":
        ui_integrazioni()


if __name__ == "__main__":
    main()
